#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
#    Copyright 2008, Lukas Lueg, knabberknusperhaus@yahoo.de
#
#    This file is part of Pyrit.
#
#    Pyrit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Pyrit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Pyrit.  If not, see <http://www.gnu.org/licenses/>.


import time, zlib, getopt, hashlib, fcntl, os, re, struct, random, sys, threading, struct, sqlite3

import cpyrit

class Pyrit_CLI(object):
    class options(object):
        def __init__(self):
            self.essidstore_path = os.path.expanduser(os.path.sep.join(('~','.pyrit','blobspace','essid')))
            self.passwdstore_path = os.path.expanduser(os.path.sep.join(('~','.pyrit','blobspace','password')))
            self.essid = None
            self.file = None
            self.verbose = True
    
    def __init__(self):
        # I *hate* the lookup syntax in the code further below if options is a dict
        self.options = self.options()
        
    def tell(self, text, sep=' ', end='\n', stream=sys.stdout, flush=False):
        if self.options.verbose or stream != sys.stdout:
            stream.write(text)
            if end is not None:
                stream.write(end)
            else:
                if sep is not None:
                    stream.write(sep)
            if flush or end is None:
                stream.flush()
        
    def init(self):
        options, commands = getopt.getopt(sys.argv[1:], "u:v:c:e:f:")
        for option, value in dict(options).items():
            if option == '-u':
                self.options.essidstore_path = value
            elif option == '-v':
                self.options.passwdstore_path = value
            elif option == '-e':
                self.options.essid = value
            elif option == '-f':
                self.options.file = value
            else:
                self.tell("Option '%s' not known. Ignoring..." % option)
        
        if self.options.file == "-" or 'passthrough' in commands:
            self.options.verbose = False

        self.essidstore = EssidStore(self.options.essidstore_path)
        self.passwdstore = PasswordStore(self.options.passwdstore_path)

        self.cp = cpyrit.CPyrit()

        self.tell("The Pyrit commandline-client (C) 2008 Lukas Lueg http://pyrit.googlecode.com" \
                "\nThis code is distributed under the GNU General Public License v3\n")
        if len(self.essidstore) == 0 and len(commands) > 0 and commands[0] != "create_essid":
            self.tell("The ESSID-blobspace seems to be empty; you should create an ESSID...\n", stream=sys.stderr)

        {'export_cowpatty': self.export_cowpatty,
        'export_hashdb': self.export_hashdb,
        'export_passwords': self.export_passwords,
        'import_passwords': self.import_passwords,
        'list_cores': self.list_cores,
        'list_essids': self.list_essids,
        'create_essid': self.create_essid,
        'eval': self.eval_results,
        'batch': self.batchprocess,
        'batchprocess': self.batchprocess,
        'passthrough': self.passthrough,
        'benchmark': self.benchmark,
        'help': self.print_help
        }.setdefault(commands[0] if len(commands) > 0 else 'help', self.print_help)()

    def print_help(self):
        self.tell("Usage: pyrit [options] command " \
            "\n\nRecognized options:" \
            "\n  -e    : ESSID for the command" \
            "\n  -f    : filename for the command ('-' is stdin/stdout)" \
            "\n  -u    : path to the ESSID-blobspace" \
            "\n  -v    : path to the Password-blobspace" \
            "\n\nRecognized commands:" \
            "\n  batch            : Batchprocess" \
            "\n  benchmark        : Determine performance of cores" \
            "\n  create_essid     : Create a new ESSID" \
            "\n  eval             : Count the passwords available and matching results" \
            "\n  export_cowpatty  : Export into a new cowpatty file" \
            "\n  export_hashdb    : Export into an existing airolib database" \
            "\n  import_passwords : Import passwords into the Password-blobspace" \
            "\n  list_cores       : List available cores" \
            "\n  list_essids      : List all ESSIDs in the ESSID-blobspace" \
            "\n  passthrough      : Compute PMKs on the fly and write to stdout" \
            "\n")

    def create_essid(self):
        essid = self.options.essid
        if essid is None:
            self.tell("One must specify a ESSID using the -e option. See 'help'", stream=sys.stderr)
        elif essid in self.essidstore:
            self.tell("ESSID already created", stream=sys.stderr)
        else:
            self.essidstore.create_essid(essid)
            self.tell("Created ESSID '%s'" % essid)

    def list_cores(self):
        self.tell("The following cores seem available...")
        for i, corename in enumerate(self.cp.availableCores()):
            self.tell("#%i:  '%s'" % (i, corename))

    def list_essids(self):
        self.tell("Listing ESSIDs...")
        for i, essid in enumerate(self.essidstore):
            self.tell("#%i:  '%s'" % (i, essid))
            
    def import_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
        else:
            self.tell("Importing from ", end=None)
            if self.options.file == "-":
                self.tell("stdin.")
                f = sys.stdin
            else:
                self.tell("'%s'" % self.options.file)
                f = open(self.options.file, "r")
            i = 0
            for line in f:
                self.passwdstore.store_password(line)
                i += 1
                if i % 10000 == 0:
                    self.tell("\r%i lines read." % i, end=None, flush=True)
            self.passwdstore.flush_buffer()
            self.tell("\r%i lines read. All done." % i)
            if f != sys.stdin:
                f.close()

    def eval_results(self):
        if self.options.essid is None:
            essids = self.essidstore
        else:
            essids = [self.options.essid]
        for essid in essids:
            self.tell("ESSID:\t '%s'" % essid)
            essid_obj = self.essidstore[essid]
            pwcount = 0
            rescount = 0
            for pwfile in self.passwdstore:
                pws = set(pwfile)
                pwcount += len(pws)
                rescount += len(pws.intersection(set(essid_obj[pwfile].results.keys())))
            self.tell("Passwords available:\t %i" % pwcount)
            self.tell("Passwords done so far:\t %i (%.2f%%)" % (rescount, (rescount * 100.0 / pwcount) if pwcount > 0 else 0.0))
            self.tell("")
    
    def export_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.file == "-":
            for pwfile in self.passwdstore:
                for row in pwfile:
                    sys.stdout.write(row)
                    sys.stdout.write("\n")
            sys.stdout.flush()
        else:
            f = open(self.options.file,"wb")
            self.tell("Exporting to '%s'..." % self.options.file)
            max_idx = 0
            lines = 0
            for pwfile in self.passwdstore:
                for row in pwfile:
                    f.write(row+"\n")
                    lines += 1
                self.tell("%i lines written\r" % lines, end=None)
            f.close()
            self.tell("\nAll done")
    
    def _genCowpHeader(self, essid):
        return struct.pack("<i3sb32s", 0x43575041, '\00'*3, len(essid), essid)
    
    def _genCowpEntry(self, passwd, pmk):
        return struct.pack("<b%ss32s" % len(passwd), len(passwd) + 32 + 1, passwd, pmk)
    
    def _genCowpatty(self, essid_obj):
        yield self._genCowpHeader(essid_obj.essid)
        for key, result in essid_obj:
            for passwd, pmk in result.items():
                yield self._genCowpEntry(passwd, pmk)
    
    def export_cowpatty(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.essid is None:
            self.tell("The cowpatty-format only supports one ESSID per file. Please specify one using the -e option.", stream=sys.stderr)
            return
        if self.options.file == "-":
            try:
                for row in self._genCowpatty(self.essidstore[self.options.essid]):
                    sys.stdout.write(row)
                sys.stdout.flush()
            except IOError:
                self.tell("IOError while exporting to stdout ignored...", stream=sys.stderr)
        else:
            f = open(self.options.file, "wb")
            self.tell("Exporting to '%s'..." % self.options.file)
            lines = 0
            for row in self._genCowpatty(self.essidstore[self.options.essid]):
                f.write(row)
                lines += 1
                if lines % 10000 == 0:
                    self.tell("\r%i entries written..." % lines, end=None, flush=True)
            self.tell("\r%i entries written. All done." % lines)
            f.close()

    def passthrough(self):
        if self.options.essid is None:
            self.tell("Specifiy a ESSID using the -e option. See 'help'", stream=sys.stderr)
            return
        if self.options.file is None:
            self.tell("Specify a filename using the -f option to read passwords from. See 'help'", stream=sys.stderr)
            return
        if self.options.file == "-":
            f = sys.stdin
        else:
            f = open(self.options.file, "r")
        try:
            sys.stdout.write(self._genCowpHeader(self.options.essid))
            workunits = []
            pwbuffer = set()
            while True:
                l = f.readline()
                if not l:
                    break
                pw = l.strip()[:63]
                if len(pw) >= 8:
                    pwbuffer.add(pw)
                if len(pwbuffer) > 10000:
                    workunits.append(list(pwbuffer))
                    self.cp.enqueue(self.options.essid, workunits[-1], 10)
                    pwbuffer = set()
                r = self.cp.dequeue(block=False)
                if r is not None:
                    for pw, pmk in zip(workunits.pop(0), r):
                        sys.stdout.write(self._genCowpEntry(pw, pmk))
            for r in self.cp:
                for pw, pmk in zip(workunits.pop(0), r):
                    sys.stdout.write(self._genCowpEntry(pw, pmk))
        except IOError:
            self.tell("IOError while writing to stdout ignored...", stream=sys.stderr)
        finally:
            f.close()

    def export_hashdb(self):
        if self.options.file is None:
            self.tell("You must specify the database filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.essid is None:
            essids = self.essidstore
        else:
            essids = [self.options.essid]

        con = sqlite3.connect(self.options.file)
        cur = con.cursor()
        cur.execute('SELECT * FROM sqlite_master')
        tbls = [x[1] for x in cur.fetchall() if x[0] == u'table']
        if u'pmk' not in tbls or u'essid' not in tbls or u'passwd' not in tbls:
            raise Exception, "The database '%s' seems to be uninitialized. Pyrit won't do that for you. Use the proper tools to create a new database." % self.options.file

        for essid in essids:
            self.tell("Exporting ESSID '%s'" % essid)
            essid_obj = self.essidstore[essid]
            try:
                cur.execute('INSERT OR IGNORE INTO essid (essid) VALUES (?)', (essid,))
                essid_id = cur.execute('SELECT essid_id FROM essid WHERE essid = ?', (essid,)).fetchone()[0]
                cur.execute('CREATE TEMPORARY TABLE import (passwd_id int key, passwd text key, pmk blob)')
                for key, result in essid_obj:
                    cur.executemany('INSERT INTO import (passwd, pmk) VALUES (?,?)', ((pw, buffer(res)) for pw, res in result.items()))
                cur.execute('UPDATE import SET passwd_id = (SELECT passwd.passwd_id FROM passwd WHERE passwd.passwd = import.passwd)')
                cur.execute('INSERT INTO passwd (passwd) SELECT passwd FROM import WHERE import.passwd_id IS NULL')
                cur.execute('UPDATE import SET passwd_id = (SELECT passwd.passwd_id FROM passwd WHERE passwd.passwd = import.passwd) WHERE passwd_id IS NULL')
                cur.execute('INSERT OR IGNORE INTO pmk (essid_id,passwd_id,pmk) SELECT ?, passwd_id, pmk FROM import', (essid_id,))
                cur.execute('DROP TABLE import')
            except:
                con.rollback()
                cur.close()
                con.close()
                self.tell("There was an error while exporting. The database has not been modified...", stream=sys.stderr)
                raise
        con.commit()
        cur.close()
        con.close()

    def batchprocess(self):
        def _writeCowpatty(resFile):
            if self.options.file == '-':
                try:
                    for passwd, pmk in resFile.results.items():
                        sys.stdout.write(self._genCowpEntry(passwd, pmk))
                except IOError:
                    self.tell("IOError while writing to stdout. Batchprocessing continues silelently...", stream=sys.stderr)
                    self.options.file = ''                        
        
        if self.options.file == "-" and self.options.essid is None:
            self.tell("Results will be written to stdout while batchprocessing. This requires to specify a ESSID.", stream=sys.stderr) 
            return
            
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = self.essidstore

        pwfile = None
        try: 
            totalResCount = 0
            startTime = time.time()
            workunits = []
            for essid in essids:
                essid_object = self.essidstore[essid]
                self.tell("Working on ESSID '%s'" % essid_object.essid)
                if self.options.file == "-":
                    sys.stdout.write(self._genCowpHeader(essid_object.essid))

                for pwfile in self.passwdstore:
                    resFile = essid_object[pwfile]
                    unsolvedPasswds = list(set(pwfile).difference(set(resFile.results.keys())))
                    if len(unsolvedPasswds) > 0:
                        workunits.append((resFile, unsolvedPasswds))
                        self.cp.enqueue(essid_object.essid, unsolvedPasswds, True)
                    else:
                        _writeCowpatty(resFile)
                    newResults = self.cp.dequeue(block=False)
                    if newResults is not None:
                        newResFile, solvedPasswds = workunits.pop(0)
                        newResFile.results.update(zip(solvedPasswds, newResults))
                        newResFile.savefile()
                        _writeCowpatty(newResFile)
                        totalResCount += len(newResults)
                    tdiff = time.time() - startTime
                    self.tell("Computed %i PMKs in %.2f seconds; %.1f PMKs per second.\r" % (totalResCount, tdiff, totalResCount / tdiff), end=None)
            self.tell("Stopped reading workunits...")
            for newResults in self.cp:
                newResFile, solvedPasswds = workunits.pop(0)
                newResFile.results.update(zip(solvedPasswds, newResults))
                newResFile.savefile()
                _writeCowpatty(newResFile)
                totalResCount += len(newResults)

        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        except:
            self.tell("Unhandled exception while batchprocessing '%s'" % pwfile, stream=sys.stderr)
            raise
        finally:
            try:
                if totalResCount > 0:   
                    self.tell("\nAll done. %.2f PMKs/s total." % (totalResCount / tdiff))
                    tdiff = time.time() - startTime
                    for core in self.cp.cores:
                        resCount, compTime = core.getStats()
                        self.tell("%s: %.2f PMKs/s, %.2f%% occupancy" % (core.name, resCount / compTime , compTime * 100.0 / tdiff))
            except:
                raise
        self.tell("Batchprocessing done.")

    def benchmark(self):
        print "Running benchmark for at least 60 seconds...\n"
        t = time.time()
        while time.time() - t < 60:
            self.cp.enqueue('foo', ['barbarbar']*2500, block=True)
            while True:
                r = self.cp.dequeue(block=False)
                if r is None:
                    break
        for r in self.cp:
            pass
        total = 0
        tdiff = time.time() - t
        for core in self.cp.cores:
            resCount, compTime = core.getStats()
            print "%s: %.2f PMKs/s, %.2f%% occupancy" % (core.name, resCount / compTime , compTime * 100.0 / tdiff)
            total += resCount / compTime
        print "\nBenchmark done. %.2f PMKs/s total." % total


class PyrFile(object):
    def __init__(self, essid, infile):
        self.results = {}
        self.essid = essid
        self.f = None
        self.key = None

        f = open(infile, "a+b")
        fcntl.flock(f.fileno(), fcntl.LOCK_SH)
        self.key = infile.split(os.path.sep)[-1][:-4]
        f.seek(0)
        try:
            preheadfmt = "<4sH"
            prehead = f.read(struct.calcsize(preheadfmt))
            if len(prehead) == 0:
                self.f = f
            else:
                magic, essidlen = struct.unpack(preheadfmt, prehead)
                assert magic == "PYRT"
                infile_digest = hashlib.md5()
                nextheadfmt = "<%ssi%ss" % (essidlen,infile_digest.digest_size)
                essid, inplength, digest = struct.unpack(nextheadfmt, f.read(struct.calcsize(nextheadfmt)))
                assert essid == self.essid
                infile_digest.update(essid)

                pmkbuffer = f.read(inplength * 32)
                assert len(pmkbuffer) == inplength * 32
                pmkbuffer = [pmkbuffer[i*32:i*32+32] for i in xrange(inplength)]
                inp = zlib.decompress(f.read()).split('\00')
                
                for i in pmkbuffer:
                    infile_digest.update(i)
                for i in inp:
                    infile_digest.update(i)
                if infile_digest.digest() != digest:
                    raise Exception, "Digest check failed on PyrFile '%s'." % self

                results = dict(zip(inp, pmkbuffer))
                self.essid = essid
                self.results = results
                self.f = f
        except:
            print >>sys.stderr, "Exception while opening PyrFile '%s', file not loaded." % infile
            fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            f.close()
            raise

    def close(self):
        if self.f is not None:
            fcntl.flock(self.f.fileno(), fcntl.LOCK_UN)
            self.f.close()
            self.f = None

    def savefile(self):
        if self.f is None:
            raise Exception, "No file opened."
        if self.essid is None or len(self.essid) == 0:
            raise Exception, "ESSID not set."
        fcntl.flock(self.f.fileno(), fcntl.LOCK_EX)
        self.f.truncate(0)
        pwbuffer,pmkbuffer = zip(*self.results.iteritems())
        raw_digest = hashlib.md5()
        raw_digest.update(self.essid)
        map(raw_digest.update, pmkbuffer)
        map(raw_digest.update, pwbuffer)
        headfmt = "<4sH%ssi%ss" % (len(self.essid),raw_digest.digest_size)
        self.f.write(struct.pack(headfmt, "PYRT", len(self.essid), self.essid, len(pmkbuffer), raw_digest.digest()))
        map(self.f.write, pmkbuffer)
        self.f.write(zlib.compress("\00".join(pwbuffer)))
        self.f.flush()
        fcntl.flock(self.f.fileno(), fcntl.LOCK_SH)


class ESSID(object):
    def __init__(self, path):
        self.path = path
        try:
            self.f = open(os.path.join(path, "essid"), "rb")
            fcntl.flock(self.f.fileno(), fcntl.LOCK_SH)
        except IOError:
            raise IOError, "ESSID not found or not accessible."
        self.essid = self.f.read()

    def __len__(self):
        return len([x[:-4] for x in os.listdir(self.path) if x[-4:] == '.pyr'])

    def __iter__(self):
        if self.f is None:
            raise Exception, "ESSID not locked."
        for key, results in ((k, dict(self._getPyrFile(k).results)) for k in (x[:-4] for x in os.listdir(self.path) if x[-4:] == '.pyr')):
            yield (key, results)

    def __getitem__(self, key):
        return self._getPyrFile(key)
        
    def __setitem__(self, key, value):
        assert isinstance(value, dict)
        pyrfile = self._getPyrFile(key)
        pyrfile.results = value
        self.resultwriter.savefile(pyrfile)

    def close(self):
        if self.f is not None:
            fcntl.flock(self.f.fileno(), fcntl.LOCK_UN)
            self.f.close()
        self.f = None
        self.path = None
        self.essid = None
     
    def _getPyrFile(self, key):
        if self.f is None:
            raise Exception, "ESSID not locked."
        if isinstance(key, str):
            fname = key
        elif isinstance(key, PasswordFile):
            fname = key.key
        else:
            raise AssertionError, "Don't know how to get results based on parameter of class '%s'." % key.__class__
        return PyrFile(self.essid, os.path.join(self.path, fname+".pyr"))


class EssidStore(object):
    def __init__(self,basepath):
        self.essidpath = basepath
        self._makedir(self.essidpath)

    def _makedir(self, pathname):
        try:
            os.makedirs(pathname)
        except OSError, (errno, sterrno):
            if errno == 17:
                pass
            else:
                raise

    def _getessidroot(self, essid):
        return os.path.join(self.essidpath, hashlib.md5(essid).hexdigest()[:8])

    def __getitem__(self, essid):
        return ESSID(self._getessidroot(essid))

    def __len__(self):
        return len([x for x in self])

    def __iter__(self):
        for essid_hash in os.listdir(self.essidpath):
            f = open(os.path.join(self.essidpath, essid_hash,'essid'), "rb")
            essid = f.read()
            f.close()
            if essid_hash == hashlib.md5(essid).hexdigest()[:8]:
                yield essid
            else:
                print >>sys.stderr, "ESSID %s seems to be corrupted." % essid_hash

    def create_essid(self,essid):
        if len(essid) < 3 or len(essid) > 32:
            raise Exception, "ESSID invalid."
        essid_root = self._getessidroot(essid)
        self._makedir(essid_root)
        f = open(os.path.join(essid_root,'essid'),"wb")
        f.write(essid)
        f.close()


class PasswordFile(object):
    def __init__(self, filename):
        self.bucket = set()
        self.f = None
        f = open(filename, "a+b")
        fcntl.flock(f.fileno(), fcntl.LOCK_SH)
        f.seek(0)
        self.f = f
        try:
            inp = set()
            md = hashlib.md5()
            head = f.read(4)
            if len(head) > 0:
                assert head == "PAWD"
                digest = f.read(md.digest_size)
                inp = sorted(f.read().split("\00"))
                map(md.update, inp)
                if digest == md.digest():
                    if filename[-3-len(md.hexdigest()):-3] != md.hexdigest():
                        raise Exception, "File '%s' doesn't match the key '%s'." % (filename, md.hexdigest())
                    self.bucket = frozenset(inp)
                    self.key = md.hexdigest()
                else:
                    print >>sys.stderr, "Digest check failed for %s" % filename
                    fcntl.flock(f.fileno(), fcntl.LOCK_UN)
                    f.close()
                    self.f = None
        except:
            print >>sys.stderr, "Exception while opening PasswordFile '%s', file not loaded." % filename
            fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            f.close()
            self.f = None
            raise
            
    def __repr__(self):
        return self.f.__repr__()

    def __del__(self):
        if self.f is not None:
            fcntl.flock(self.f.fileno(), fcntl.LOCK_UN)
            self.f.close()

    def __iter__(self):
        for pw in self.bucket:
            yield pw
            
    def __len__(self):
        return len(self.bucket)

    def savefile(self):
        if self.f is None:
            raise Exception, "No file opened."
        fcntl.flock(self.f.fileno(), fcntl.LOCK_EX)
        md = hashlib.md5()
        b = sorted(list(self.bucket))
        map(md.update, b)
        self.f.truncate(0)
        self.f.write("PAWD")
        self.f.write(md.digest())
        self.f.write("\00".join(b))
        self.f.flush()
        fcntl.flock(self.f.fileno(), fcntl.LOCK_SH)


class PasswordStore(object):
    def __init__(self, basepath):
        self.passwdpath = basepath
        self._makedir(self.passwdpath)
        self.pwbuffer = {}

    def _makedir(self,pathname):
        try:
            os.makedirs(pathname)
        except OSError, (errno, sterrno):
            if errno == 17:
                pass

    def __del__(self):
        self.flush_buffer()

    def _getfiles(self):
        pwfiles = {}
        for pw_h1 in [x for x in os.listdir(self.passwdpath)]:
            for pw in [x for x in os.listdir(os.path.join(self.passwdpath, pw_h1)) if x[-3:] == '.pw']:
                pwfiles[pw[:len(pw)-3]] = os.path.join(self.passwdpath, pw_h1, pw)
        return pwfiles

    def __iter__(self):
        for pwf in self._getfiles().values():
            yield PasswordFile(pwf)

    def __getitem__(self, key):
        return PasswordFile(self._getfiles()[key])

    def _flush_bucket(self, bucket):
        if len(bucket) == 0:
            return
        pw_h1 = "%02.2X" % (hash(list(bucket)[0]) & 0xFF)
        assert all(("%02.2X" % (hash(pw) & 0xFF) == pw_h1 for pw in bucket))

        for pwfile in self._getfiles().values():
            if pwfile.split(os.path.sep)[-2] == pw_h1:
                bucket -= PasswordFile(pwfile).bucket
        if len(bucket) == 0:
            return
            
        md = hashlib.md5()
        map(md.update, sorted(list(bucket)))
        destpath = os.path.join(self.passwdpath, pw_h1)
        self._makedir(destpath)
        f = PasswordFile(os.path.join(destpath, md.hexdigest() + ".pw"))
        f.bucket.update(bucket)
        f.savefile()
        bucket = set()

    def flush_buffer(self):
        for pw_h1 in self.pwbuffer.keys():
            pwbucket = list(self.pwbuffer[pw_h1])
            map(self._flush_bucket, [set(pwbucket[x:x+10000]) for x in xrange(0, len(pwbucket), 10000)])

    def store_password(self, passwd):
        passwd = passwd.strip()
        if len(passwd) < 8 or len(passwd) > 63:
            #print "Password '%s'('%s') has invalid length." % (pwstrip,passwd)
            return
        pw_h1 = "%02.2X" % (hash(passwd) & 0xFF)
        pw_bucket = self.pwbuffer.setdefault(pw_h1, set())
        pw_bucket.add(passwd)
        if len(pw_bucket) >= 10000:
            self._flush_bucket(pw_bucket)


if __name__ == "__main__":
    p = Pyrit_CLI()
    p.init()

