#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
#    Copyright 2008, 2009, Lukas Lueg, lukas.lueg@gmail.com
#
#    This file is part of Pyrit.
#
#    Pyrit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Pyrit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Pyrit.  If not, see <http://www.gnu.org/licenses/>.

import getopt
import hashlib
import httplib
import os
import random
import sys
import sqlite3
import threading
import time
import cpyrit_util as util

class Pyrit_CLI(object):
    class options(object):
        def __init__(self):
            self.essidstore_path = os.path.expanduser(os.path.join('~','.pyrit','blobspace','essid'))
            self.passwdstore_path = os.path.expanduser(os.path.join('~','.pyrit','blobspace','password'))
            self.essid = None
            self.file = None
            self.verbose = True

    def __init__(self):
        # I *hate* the lookup syntax in the code further below if options is a dict
        self.options = self.options()
        
    def tell(self, text, sep=' ', end='\n', stream=sys.stdout, flush=False):
        if self.options.verbose or stream != sys.stdout:
            stream.write(text)
            if end is not None:
                stream.write(end)
            else:
                if sep is not None:
                    stream.write(sep)
            if flush or end is None:
                stream.flush()
        
    def init(self):
        options, commands = getopt.getopt(sys.argv[1:], 'u:v:c:e:f:')
        for option, value in dict(options).items():
            if option == '-e':
                self.options.essid = value
            elif option == '-f':
                self.options.file = value
            else:
                self.tell("Option '%s' not known. Ignoring..." % option)
        if self.options.file == '-' or 'passthrough' in commands:
            self.options.verbose = False

        self.essidstore = util.EssidStore(self.options.essidstore_path)
        self.passwdstore = util.PasswordStore(self.options.passwdstore_path)

        self.tell('Pyrit %s (C) 2008, 2009 Lukas Lueg http://pyrit.googlecode.com' \
                '\nThis code is distributed under the GNU General Public License v3\n' % util.VERSION)
        if len(self.essidstore) == 0 and len(commands) > 0 and commands[0] != 'create_essid':
            self.tell('The ESSID-blobspace seems to be empty; you should create an ESSID...\n', stream=sys.stderr)

        {'export_cowpatty': self.export_cowpatty,
        'export_hashdb': self.export_hashdb,
        'export_passwords': self.export_passwords,
        'import_passwords': self.import_passwords,
        'list_cores': self.list_cores,
        'list_essids': self.list_essids,
        'create_essid': self.create_essid,
        'delete_essid': self.delete_essid,
        'eval': self.eval_results,
        'batch': self.batchprocess,
        'batchprocess': self.batchprocess,
        'passthrough': self.passthrough,
        'benchmark': self.benchmark,
        'serve': self.serve,
        'selftest': self.selftest,
        'verify': self.verify,
        'help': self.print_help
        }.setdefault(commands[0] if len(commands) > 0 else 'help', self.print_help)()

    def print_help(self):
        self.tell('Usage: pyrit [options] command'  \
            '\n\nRecognized options:' \
            '\n  -e    : ESSID for the command' \
            "\n  -f    : filename for the command ('-' is stdin/stdout)" \
            '\n\nRecognized commands:' \
            '\n  batch            : Batchprocess' \
            '\n  benchmark        : Determine performance of available cores' \
            '\n  create_essid     : Create a new ESSID' \
            '\n  delete_essid     : Delete a ESSID and corresponding results' \
            '\n  eval             : Count the available passwords and matching results' \
            '\n  export_cowpatty  : Export into a new cowpatty file' \
            '\n  export_hashdb    : Export into an airolib database' \
            '\n  import_passwords : Import passwords' \
            '\n  list_cores       : List available cores' \
            "\n  list_essids      : List all ESSIDs but don't count matching results" \
            '\n  passthrough      : Compute PMKs on the fly and write to stdout' \
            '\n  serve            : Serve requests from clients on the network' \
            '\n  selftest         : Test all cores to ensure they compute correct results' \
            '\n  verify           : Verify 10% of the results by recomputation' \
            '\n')

    def create_essid(self):
        if self.options.essid is None:
            self.tell("You must specify a ESSID using the -e option. See 'help'.", stream=sys.stderr)
        elif self.options.essid in self.essidstore:
            self.tell("ESSID already created", stream=sys.stderr)
        else:
            self.essidstore.create_essid(self.options.essid)
            self.tell("Created ESSID '%s'" % self.options.essid)

    def delete_essid(self):
        if self.options.essid is None:
            self.tell("You must specify a ESSID using the -e option. See 'help'.", stream=sys.stderr)
        elif self.options.essid not in self.essidstore:
            self.tell("ESSID not found...", stream=sys.stderr)
        else:
            self.tell("All results for ESSID '%s' will be deleted! Continue? [y/N]" % self.options.essid, end=None)
            if sys.stdin.readline().strip() == 'y':
                self.tell("deleting...")
                self.essidstore.delete_essid(self.options.essid)
                self.tell("Deleted ESSID '%s'." % self.options.essid)
            else:
                self.tell("aborted.")

    def list_cores(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        self.tell("The following cores seem available...")
        for i, core in enumerate(cp.cores):
            self.tell("#%i:  '%s'" % (i+1, core))

    def list_essids(self):
        self.tell("Listing ESSIDs...")
        for i, essid in enumerate(self.essidstore):
            self.tell("#%i:  '%s'" % (i, essid))

    def eval_results(self):
        essid_results = dict.fromkeys(self.essidstore, 0)
        pwcount = 0
        for key, passwords in self.passwdstore.iteritems():
            pwcount += len(passwords)
            self.tell("Passwords available:\t%i\r" % pwcount, end=None, sep=None)
            for essid in essid_results:
                # Let's assume that the presence of the key in the essidstore means that the file is valid and completed...
                essid_results[essid] += len(passwords) if self.essidstore.containskey(essid, key) else 0
        self.tell("Passwords available:\t%i\n" % pwcount)
        for essid, rescount in sorted(essid_results.iteritems()):
            self.tell("ESSID '%s':\t%i (%.2f%%)" % (essid, rescount, (rescount * 100.0 / pwcount) if pwcount > 0 else 0.0))
        self.tell("")
            
    def import_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
        else:
            self.tell("Importing from", end=None)
            if self.options.file == "-":
                self.tell("stdin.")
                f = sys.stdin
            else:
                self.tell("'%s'" % self.options.file)
                f = open(self.options.file, 'r')
            for i, line in enumerate(f):
                self.passwdstore.store_password(line)
                if i % 100000 == 0:
                    self.tell("\r%i lines read." % i, end=None, flush=True)
            f.close()
            self.tell("\r%i lines read. Flushing buffers..." % (i + 1))
            self.passwdstore.flush_buffer()
            self.tell('All done.')

    def export_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.file == '-':
            f = sys.stdout
        else:
            self.tell("Exporting to '%s'..." % self.options.file)
            f = open(self.options.file, 'wb')
        lines = 0
        awriter = util.AsyncFileWriter(f)
        try:
            for pwset in self.passwdstore.iterpasswords():
                awriter.write('\n'.join(pwset))
                awriter.write('\n')
                lines += len(pwset)
                self.tell("%i lines written\r" % lines, end=None, sep=None)
            self.tell("\nAll done")
        finally:
            awriter.closeAsync()
            f.close()
    
    def export_cowpatty(self):
        if self.options.file is None:
            self.tell("You must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.essid is None:
            essid = self.options.file.split('.')[0]
            if essid in self.essidstore:
                self.options.essid = essid
            else:
                self.tell("The cowpatty-format only supports one ESSID per file. Please specify one using the -e option.", stream=sys.stderr)
                return
        if self.options.essid not in self.essidstore:
            self.tell("The ESSID you specified can't be found in the storage.", stream=sys.stderr)
            return
        f = sys.stdout if self.options.file == '-' else open(self.options.file, 'wb')
        lines = 0
        self.tell("Exporting to '%s'..." % self.options.file)
        awriter = util.AsyncFileWriter(f)
        try:
            awriter.write(util.genCowpHeader(self.options.essid))
            for results in self.essidstore.iterresults(self.options.essid):
                awriter.write(util.genCowpEntries(results))
                lines += len(results)
                self.tell("\r%i entries written..." % lines, end=None, sep=None)
            self.tell("\r%i entries written. All done." % lines)
        except IOError:
            self.tell("IOError while exporting to stdout ignored...", stream=sys.stderr)
        finally:
            awriter.closeAsync()
            f.close()

    def passthrough(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        if self.options.essid is None:
            self.tell("Specifiy a ESSID using the -e option. See 'help'", stream=sys.stderr)
            return
        if self.options.file is None:
            self.tell("Specify a filename using the -f option to read passwords from. See 'help'", stream=sys.stderr)
            return
        f = sys.stdin if self.options.file == '-' else open(self.options.file, 'r')
        awriter = util.AsyncFileWriter(sys.stdout)       
        try:
            awriter.write(util.genCowpHeader(self.options.essid))
            workunits = []
            pwbuffer = set()
            for line in f:
                pw = line.strip()[:63]
                if len(pw) >= 8:
                    pwbuffer.add(pw)
                if len(pwbuffer) > 20000:
                    workunits.append(pwbuffer)
                    cp.enqueue(self.options.essid, workunits[-1], True)
                    pwbuffer = set()
                    while True:
                        solvedPMKs = cp.dequeue(block=False)
                        if solvedPMKs is not None:
                            awriter.write(util.genCowpEntries(zip(workunits.pop(0), solvedPMKs)))
                        else:
                            break
            if len(pwbuffer) > 0:
                workunits.append(pwbuffer)
                cp.enqueue(self.options.essid, workunits[-1], True)
            for solvedPMKs in cp:
                awriter.write(util.genCowpEntries(zip(workunits.pop(0), solvedPMKs)))
        except IOError:
            self.tell("IOError while writing to stdout ignored...", stream=sys.stderr)
        finally:
            awriter.closeAsync()
            f.close()

    def export_hashdb(self):
        if self.options.file is None:
            self.tell("You must specify the database filename using the -f option. See 'help'", stream=sys.stderr)
            return
        essids = list(self.essidstore) if self.options.essid is None else [self.options.essid]

        con = sqlite3.connect(self.options.file)
        con.text_factory = str
        cur = con.cursor()
        cur.execute('SELECT * FROM sqlite_master')
        tbls = [x[1] for x in cur.fetchall() if x[0] == u'table']
        if u'pmk' not in tbls or u'essid' not in tbls or u'passwd' not in tbls:
            self.tell("The database '%s' seems to be uninitialized. "  % self.options.file +
                      "Trying to create default table-layout...", end=None)
            try:
                cur.execute("CREATE TABLE essid (essid_id INTEGER PRIMARY KEY AUTOINCREMENT, essid TEXT, prio INTEGER DEFAULT 64)")
                cur.execute("CREATE TABLE passwd (passwd_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd TEXT)")
                cur.execute("CREATE TABLE pmk (pmk_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd_id INT, essid_id INT, pmk BLOB)")
                cur.execute("CREATE TABLE workbench (wb_id INTEGER PRIMARY KEY AUTOINCREMENT, essid_id INT, passwd_id INT, lockid INTEGER DEFAULT 0)")
                cur.execute("CREATE INDEX lock_lockid ON workbench (lockid);")
                cur.execute("CREATE UNIQUE INDEX essid_u ON essid (essid)")
                cur.execute("CREATE UNIQUE INDEX passwd_u ON passwd (passwd)")
                cur.execute("CREATE UNIQUE INDEX ep_u ON pmk (essid_id, passwd_id)")
                cur.execute("CREATE UNIQUE INDEX wb_u ON workbench (essid_id, passwd_id)")
                cur.execute("CREATE TRIGGER delete_essid DELETE ON essid BEGIN DELETE FROM pmk WHERE pmk.essid_id = OLD.essid_id; DELETE FROM workbench WHERE workbench.essid_id = OLD.essid_id; END;")
                cur.execute("CREATE TRIGGER delete_passwd DELETE ON passwd BEGIN DELETE FROM pmk WHERE pmk.passwd_id = OLD.passwd_id; DELETE FROM workbench WHERE workbench.passwd_id = OLD.passwd_id; END;")
                self.tell("Tables created...")
            except:
                con.rollback()
                cur.close()
                con.close()
                self.tell("Failed to initialize the database:", stream=sys.stderr)
                raise
        try:
            cur.execute("PRAGMA synchronous = 1")
            i = 0
            print "Writing passwords..."
            for pwset in self.passwdstore.iterpasswords():
                i += len(pwset)
                cur.executemany('INSERT OR IGNORE INTO passwd (passwd) VALUES (?)', [(pw,) for pw in pwset])
                self.tell("Wrote %i lines...\r" % i, end=None, sep=None)
            print "\nWriting ESSIDs and results..."
            for essid in essids:
                self.tell("Writing '%s'..." % essid)
                cur.execute('INSERT OR IGNORE INTO essid (essid) VALUES (?)', (essid,))
                essid_id = cur.execute('SELECT essid_id FROM essid WHERE essid = ?', (essid,)).fetchone()[0]
                i = 0
                for results in self.essidstore.iterresults(essid):
                    i += len(results)
                    cur.executemany('INSERT OR IGNORE INTO pmk (essid_id, passwd_id, pmk) SELECT ?, passwd_id, ? FROM passwd WHERE passwd = ?',
                                    ((essid_id, buffer(pmk), pw) for pw, pmk in results))
                    self.tell("Wrote %i lines...\r" % i, end=None, sep=None)
            print "\nAll done."
        except:
            con.rollback()
            self.tell("There was an error while exporting. The database has not been modified...", stream=sys.stderr)
            raise
        else:
            con.commit()
        finally:
            cur.close()
            con.close()

    def batchprocess(self):
        import cpyrit
        cp = cpyrit.CPyrit()

        def _writeCowpatty(out, results):
            if self.options.file == '-':
                try:
                    out.write(util.genCowpEntries(results))
                except IOError:
                    self.tell("IOError while writing to stdout. Batchprocessing continues silently...", stream=sys.stderr)
                    self.options.file = ''                        
        
        if self.options.file == "-" and self.options.essid is None:
            self.tell("Results will be written to stdout while batchprocessing. This requires to specify a ESSID.", stream=sys.stderr) 
            return
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = list(self.essidstore)
        
        totalResCount = 0
        startTime = time.time()
        workunits = []
        awriter = util.AsyncFileWriter(sys.stdout) 
        try:
            for essid in essids:
                self.tell("Working on ESSID '%s'" % essid)
                if self.options.file == "-":
                    awriter.write(util.genCowpHeader(essid))
                for key in self.passwdstore:
                    if self.essidstore.containskey(essid, key):
                        _writeCowpatty(awriter, self.essidstore[essid, key])
                    else:
                        passwords = self.passwdstore[key]
                        workunits.append((essid, key, passwords))
                        cp.enqueue(essid, passwords, block=True)
                        solvedPMKs = cp.dequeue(block=False)
                        if solvedPMKs is not None:
                            solvedEssid, solvedKey, solvedPasswords = workunits.pop(0)
                            solvedResults = zip(solvedPasswords, solvedPMKs)
                            self.essidstore[solvedEssid, solvedKey] = solvedResults
                            totalResCount += len(solvedResults)
                            _writeCowpatty(awriter, solvedResults)
                    self.tell("Computed %i PMKs so far; %i PMKs per second; %i passwords buffered.\r" % \
                                (totalResCount, totalResCount / (time.time() - startTime), len(cp)), end=None, sep=None)
                self.tell('')
            self.tell("Stopped reading workunits...")
            for solvedPMKs in cp:
                self.tell("Computed %i PMKs so far; %i PMKs per second; %i passwords buffered.\r" % \
                            (totalResCount, totalResCount / (time.time() - startTime), len(cp)), end=None, sep=None)
                solvedEssid, solvedKey, solvedPasswords = workunits.pop(0)
                solvedResults = zip(solvedPasswords, solvedPMKs)
                self.essidstore[solvedEssid, solvedKey] = solvedResults
                totalResCount += len(solvedResults)
                _writeCowpatty(awriter, solvedResults)
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        finally:
            awriter.closeAsync()
            if totalResCount > 0:   
                tdiff = time.time() - startTime
                self.tell("\nAll done. %.2f PMKs/s total." % (totalResCount / tdiff))
                for i, core in enumerate(cp.cores):
                   perf = core.resCount / core.compTime if core.compTime > 0 else 0
                   rtt = (core.resCount / core.callCount) / perf if core.callCount > 0 and perf > 0 else 0
                   self.tell("#%i: '%s': %.2f PMKs/s (Occupancy %.2f%%; RTT %.1f secs)" % \
                                (i+1, core.name, perf, core.compTime * 100.0 / tdiff, rtt))
        self.tell("Batchprocessing done.")

    def benchmark(self):
        import cpyrit
        cp = cpyrit.CPyrit(maxBufferSize=10000)
        self.tell("Running benchmark for at least 60 seconds...\n")
        t = time.time()
        pws = ['barbarbar']*3500
        while time.time() - t < 60:
            cp.enqueue('foo', pws, block=True)
            while True:
                r = cp.dequeue(block=False)
                if not r:
                    break
        for r in cp:
            pass
        total = 0
        tdiff = time.time() - t
        for i, core in enumerate(cp.cores):
            perf = core.resCount / core.compTime if core.compTime > 0 else 0
            rtt = (core.resCount / core.callCount) / perf if core.callCount > 0 and perf > 0 else 0
            self.tell("#%i: '%s': %.2f PMKs/s (Occupancy %.2f%%; RTT %.1f secs)" \
                        % (i+1, core.name, perf, core.compTime * 100.0 / tdiff, rtt))
            total += perf
        self.tell("\nBenchmark done. %.2f PMKs/s total." % total)

    def selftest(self):
        import cpyrit
        cp = cpyrit.CPyrit(maxBufferSize=10000)
        self.tell("Cores incorporated in the test:")
        for i, core in enumerate(cp.cores):
            self.tell("#%i:  '%s'" % (i+1, core))
        self.tell("\nRunning selftest for at least 60 seconds...")
        workunits = []
        t = time.time()
        err = False
        while time.time() - t < 60 and not err:
            essid = random.choice(util.PMK_TESTVECTORS.keys())
            pws = [random.choice(util.PMK_TESTVECTORS[essid].keys()) for i in xrange(random.randrange(10, 1000))]
            workunits.append((essid, pws))
            cp.enqueue(essid, pws, block=True)
            while True:
                solvedPMKs = cp.dequeue(block=False)
                if solvedPMKs is not None:
                    essid, pws = workunits.pop(0)
                    if [util.PMK_TESTVECTORS[essid][pw] for pw in pws] != list(solvedPMKs):
                        err = True
                        break
                if err or not solvedPMKs:
                    break
        if not err:
            for solvedPMKs in cp:
                essid, pws = workunits.pop(0)
                if [util.PMK_TESTVECTORS[essid][pw] for pw in pws] != list(solvedPMKs):
                    err = True
                    break
        if err or len(workunits) != 0 or len(cp) != 0:
            self.tell("\n!!! WARNING !!!\n"\
                      "At least some results are definitly invalid. "\
                      "This may be caused by a bug in Pyrit, faulty hardware or malicious network clients. Do not trust this installation...\n",
                      stream=sys.stderr)
        else:
            self.tell("\nAll results verified. Your installation seems OK.")
    
    def verify(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = list(self.essidstore)
        totalResCount = 0
        err = False
        startTime = time.time()
        workunits = []
        try: 
            for essid in essids:
                self.tell("Verifying ESSID '%s'" % essid)
                for key, results in self.essidstore.iteritems(essid):
                    sample = random.sample(results, int(len(results) * 0.1))
                    if len(sample) > 0:
                        pws, pmks = zip(*sample)
                        workunits.append((essid, key, tuple(pmks)))
                        cp.enqueue(essid, pws, True)
                        solvedPMKs = cp.dequeue(block=False)
                        if solvedPMKs is not None:
                            totalResCount += len(solvedPMKs)
                            testedEssid, testedKey, testedPMKs = workunits.pop(0)
                            if testedPMKs != solvedPMKs:
                                self.tell("Workunit %s for ESSID '%s' seems corrupted." % (testedKey, testedEssid), stream=sys.stderr)
                                err = True
                    tdiff = time.time() - startTime
                    self.tell("Computed %i PMKs in %i seconds; %i PMKs per second.\r" % (totalResCount, tdiff, totalResCount / tdiff), end=None, sep=None)
                for solvedPMKs in cp:
                    totalResCount += len(solvedPMKs)
                    testedEssid, testedKey, testedPMKs = workunits.pop(0)
                    if testedPMKs != solvedPMKs:
                        self.tell("Workunit %s for ESSID '%s' seems corrupted." % (testedKey, testedEssid), stream=sys.stderr)
                        err = True
            self.tell("\nVerified %i PMKs with %.2f PMKs/s." % (totalResCount, totalResCount / (time.time() - startTime)))
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        if err:
            self.tell("\nAt least one workunit-file contains invalid results. There are two options now:\n"
                      "* The results on the disk are really invalid. You should mistrust the entire repository but at least delete and recompute the offending ESSIDs.\n"
                      "* The result on the disk are correct but your installation is broken and currently computes invalid results.\n"
                      "Run 'selftest' for an extensive self-test in order to tell the two options apart.",
                      stream=sys.stderr)
        else:
            self.tell("Everything seems OK.")

    def serve(self):
        self.tell('Booting...', end=None)
        import cpyrit
        httpd = cpyrit.PyritServer()
        self.tell('%s, %i cores:' % (httpd.name, len(httpd.cp.cores)))
        for i, core in enumerate(httpd.cp.cores):
            self.tell("#%i '%s'" % (i+1, core))
        try:
            httpd.serve_forever()
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")


if __name__ == "__main__":
    Pyrit_CLI().init()

