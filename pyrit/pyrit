#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
#    Copyright 2008, 2009, Lukas Lueg, knabberknusperhaus@yahoo.de
#
#    This file is part of Pyrit.
#
#    Pyrit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Pyrit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Pyrit.  If not, see <http://www.gnu.org/licenses/>.

import BaseHTTPServer
import getopt
import hashlib
import httplib
import itertools
import os
import random
import sys
import sqlite3
import SocketServer
import threading
import time
import uuid
import urlparse
import cpyrit_util as util

class Pyrit_CLI(object):
    class options(object):
        def __init__(self):
            self.essidstore_path = os.path.expanduser(os.path.join('~','.pyrit','blobspace','essid'))
            self.passwdstore_path = os.path.expanduser(os.path.join('~','.pyrit','blobspace','password'))
            self.essid = None
            self.file = None
            self.verbose = True

    def __init__(self):
        # I *hate* the lookup syntax in the code further below if options is a dict
        self.options = self.options()
        
    def tell(self, text, sep=' ', end='\n', stream=sys.stdout, flush=False):
        if self.options.verbose or stream != sys.stdout:
            stream.write(text)
            if end is not None:
                stream.write(end)
            else:
                if sep is not None:
                    stream.write(sep)
            if flush or end is None:
                stream.flush()
        
    def init(self):
        options, commands = getopt.getopt(sys.argv[1:], "u:v:c:e:f:")
        for option, value in dict(options).items():
            if option == '-e':
                self.options.essid = value
            elif option == '-f':
                self.options.file = value
            else:
                self.tell("Option '%s' not known. Ignoring..." % option)
        if self.options.file == "-" or 'passthrough' in commands:
            self.options.verbose = False

        self.essidstore = util.EssidStore(self.options.essidstore_path)
        self.passwdstore = util.PasswordStore(self.options.passwdstore_path)

        self.tell("Pyrit %s (C) 2008, 2009 Lukas Lueg http://pyrit.googlecode.com" \
                "\nThis code is distributed under the GNU General Public License v3\n" % util.VERSION)
        if len(self.essidstore) == 0 and len(commands) > 0 and commands[0] != "create_essid":
            self.tell("The ESSID-blobspace seems to be empty; you should create an ESSID...\n", stream=sys.stderr)

        {'export_cowpatty': self.export_cowpatty,
        'export_hashdb': self.export_hashdb,
        'export_passwords': self.export_passwords,
        'import_passwords': self.import_passwords,
        'list_cores': self.list_cores,
        'list_essids': self.list_essids,
        'create_essid': self.create_essid,
        'delete_essid': self.delete_essid,
        'eval': self.eval_results,
        'batch': self.batchprocess,
        'batchprocess': self.batchprocess,
        'passthrough': self.passthrough,
        'benchmark': self.benchmark,
        'serve': self.serve,
        'selftest': self.selftest,
        'verify': self.verify,
        'help': self.print_help
        }.setdefault(commands[0] if len(commands) > 0 else 'help', self.print_help)()

    def print_help(self):
        self.tell("Usage: pyrit [options] command " \
            "\n\nRecognized options:" \
            "\n  -e    : ESSID for the command" \
            "\n  -f    : filename for the command ('-' is stdin/stdout)" \
            "\n\nRecognized commands:" \
            "\n  batch            : Batchprocess" \
            "\n  benchmark        : Determine performance of available cores" \
            "\n  create_essid     : Create a new ESSID" \
            "\n  delete_essid     : Delete a ESSID and corresponding results" \
            "\n  eval             : Count the available passwords and matching results" \
            "\n  export_cowpatty  : Export into a new cowpatty file" \
            "\n  export_hashdb    : Export into an airolib database" \
            "\n  import_passwords : Import passwords" \
            "\n  list_cores       : List available cores" \
            "\n  list_essids      : List all ESSIDs but don't count matching results" \
            "\n  passthrough      : Compute PMKs on the fly and write to stdout" \
            "\n  serve            : Serve requests from clients on the network" \
            "\n  selftest         : Test all cores for computing correct results" \
            "\n  verify           : Verify 10% of the results through recomputation" \
            "\n")

    def create_essid(self):
        if self.options.essid is None:
            self.tell("You must specify a ESSID using the -e option. See 'help'.", stream=sys.stderr)
        elif self.options.essid in self.essidstore:
            self.tell("ESSID already created", stream=sys.stderr)
        else:
            self.essidstore.create_essid(self.options.essid)
            self.tell("Created ESSID '%s'" % self.options.essid)

    def delete_essid(self):
        if self.options.essid is None:
            self.tell("You must specify a ESSID using the -e option. See 'help'.", stream=sys.stderr)
        elif self.options.essid not in self.essidstore:
            self.tell("ESSID not found...", stream=sys.stderr)
        else:
            self.tell("All results for ESSID '%s' will be deleted! Continue? [y/N]" % self.options.essid, end=None)
            if sys.stdin.readline().strip() == 'y':
                self.tell("deleting...")
                self.essidstore.delete_essid(self.options.essid)
                self.tell("Deleted ESSID '%s'." % self.options.essid)
            else:
                self.tell("aborted.")

    def list_cores(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        self.tell("The following cores seem available...")
        for i, core in enumerate(cp.cores):
            self.tell("#%i:  '%s'" % (i+1, core))

    def list_essids(self):
        self.tell("Listing ESSIDs...")
        for i, essid in enumerate(self.essidstore):
            self.tell("#%i:  '%s'" % (i, essid))

    def eval_results(self):
        essid_results = dict.fromkeys(self.essidstore, 0)
        pwcount = 0
        for key in self.passwdstore:
            pwcount += len(self.passwdstore[key])
            self.tell("Passwords available:\t%i\r" % pwcount, end=None, sep=None)
            for essid in essid_results:
                essid_results[essid] += len(self.essidstore[essid, key])
        self.tell("Passwords available:\t%i\n" % pwcount)
        for essid, rescount in sorted(essid_results.iteritems()):
            self.tell("ESSID '%s':\t%i (%.2f%%)" % (essid, rescount, (rescount * 100.0 / pwcount) if pwcount > 0 else 0.0))
        self.tell("")
            
    def import_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
        else:
            self.tell("Importing from ", end=None)
            if self.options.file == "-":
                self.tell("stdin.")
                f = sys.stdin
            else:
                self.tell("'%s'" % self.options.file)
                f = open(self.options.file, "r")
            for i, line in enumerate(f):
                self.passwdstore.store_password(line)
                if i % 100000 == 0:
                    self.tell("\r%i lines read." % i, end=None, flush=True)
            f.close()
            self.tell("\r%i lines read. Flushing buffers..." % (i + 1))
            self.passwdstore.flush_buffer()
            self.tell("All done.")

    def export_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.file == '-':
            f = sys.stdout
        else:
            self.tell("Exporting to '%s'..." % self.options.file)
            f = open(self.options.file, 'wb')
        lines = 0
        awriter = util.AsyncFileWriter(f)
        try:
            for pwset in self.passwdstore.iterpasswords():
                awriter.write('\n'.join(pwset))
                awriter.write('\n')
                lines += len(pwset)
                self.tell("%i lines written\r" % lines, end=None, sep=None)
            self.tell("\nAll done")
        finally:
            awriter.close()
            f.close()
    
    def export_cowpatty(self):
        if self.options.file is None:
            self.tell("You must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.essid is None:
            essid = self.options.file.split('.')[0]
            if essid in self.essidstore:
                self.options.essid = essid
            else:
                self.tell("The cowpatty-format only supports one ESSID per file. Please specify one using the -e option.", stream=sys.stderr)
                return
        f = sys.stdout if self.options.file == '-' else open(self.options.file, 'wb')
        lines = 0
        self.tell("Exporting to '%s'..." % self.options.file)
        awriter = util.AsyncFileWriter(f)
        try:
            awriter.write(util.genCowpHeader(self.options.essid))
            for results in self.essidstore.iterresults(self.options.essid):
                awriter.write(util.genCowpEntries(results.items()))
                lines += len(results)
                self.tell("\r%i entries written..." % lines, end=None, sep=None)
            self.tell("\r%i entries written. All done." % lines)
        except IOError:
            self.tell("IOError while exporting to stdout ignored...", stream=sys.stderr)
        finally:
            awriter.close()
            f.close()

    def passthrough(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        if self.options.essid is None:
            self.tell("Specifiy a ESSID using the -e option. See 'help'", stream=sys.stderr)
            return
        if self.options.file is None:
            self.tell("Specify a filename using the -f option to read passwords from. See 'help'", stream=sys.stderr)
            return
        f = sys.stdin if self.options.file == '-' else open(self.options.file, 'r')
        awriter = util.AsyncFileWriter(sys.stdout)       
        try:
            awriter.write(util.genCowpHeader(self.options.essid))
            workunits = []
            pwbuffer = set()
            for line in f:
                pw = line.strip()[:63]
                if len(pw) >= 8:
                    pwbuffer.add(pw)
                if len(pwbuffer) > 20000:
                    workunits.append(pwbuffer)
                    cp.enqueue(self.options.essid, workunits[-1], True)
                    pwbuffer = set()
                    while True:
                        solvedPMKs = cp.dequeue(block=False)
                        if solvedPMKs is not None:
                            awriter.write(util.genCowpEntries(itertools.izip(workunits.pop(0), solvedPMKs)))
                        else:
                            break
            if len(pwbuffer) > 0:
                workunits.append(pwbuffer)
                cp.enqueue(self.options.essid, workunits[-1], True)
            for solvedPMKs in cp:
                awriter.write(util.genCowpEntries(itertools.izip(workunits.pop(0), solvedPMKs)))
        except IOError:
            self.tell("IOError while writing to stdout ignored...", stream=sys.stderr)
        finally:
            awriter.close()
            f.close()

    def export_hashdb(self):
        if self.options.file is None:
            self.tell("You must specify the database filename using the -f option. See 'help'", stream=sys.stderr)
            return
        essids = list(self.essidstore) if self.options.essid is None else [self.options.essid]

        con = sqlite3.connect(self.options.file)
        con.text_factory = str
        cur = con.cursor()
        cur.execute('SELECT * FROM sqlite_master')
        tbls = [x[1] for x in cur.fetchall() if x[0] == u'table']
        if u'pmk' not in tbls or u'essid' not in tbls or u'passwd' not in tbls:
            self.tell("The database '%s' seems to be uninitialized. "  % self.options.file +
                      "Trying to create default table-layout...", end=None)
            try:
                cur.execute("CREATE TABLE essid (essid_id INTEGER PRIMARY KEY AUTOINCREMENT, essid TEXT, prio INTEGER DEFAULT 64)")
                cur.execute("CREATE TABLE passwd (passwd_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd TEXT)")
                cur.execute("CREATE TABLE pmk (pmk_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd_id INT, essid_id INT, pmk BLOB)")
                cur.execute("CREATE TABLE workbench (wb_id INTEGER PRIMARY KEY AUTOINCREMENT, essid_id INT, passwd_id INT, lockid INTEGER DEFAULT 0)")
                cur.execute("CREATE INDEX lock_lockid ON workbench (lockid);")
                cur.execute("CREATE UNIQUE INDEX essid_u ON essid (essid)")
                cur.execute("CREATE UNIQUE INDEX passwd_u ON passwd (passwd)")
                cur.execute("CREATE UNIQUE INDEX ep_u ON pmk (essid_id, passwd_id)")
                cur.execute("CREATE UNIQUE INDEX wb_u ON workbench (essid_id, passwd_id)")
                cur.execute("CREATE TRIGGER delete_essid DELETE ON essid BEGIN DELETE FROM pmk WHERE pmk.essid_id = OLD.essid_id; DELETE FROM workbench WHERE workbench.essid_id = OLD.essid_id; END;")
                cur.execute("CREATE TRIGGER delete_passwd DELETE ON passwd BEGIN DELETE FROM pmk WHERE pmk.passwd_id = OLD.passwd_id; DELETE FROM workbench WHERE workbench.passwd_id = OLD.passwd_id; END;")
                self.tell("Tables created...")
            except:
                con.rollback()
                cur.close()
                con.close()
                self.tell("Failed to initialize the database:", stream=sys.stderr)
                raise
        try:
            cur.execute("PRAGMA synchronous = 1")
            i = 0
            print "Writing passwords..."
            for pwset in self.passwdstore.iterpasswords():
                i += len(pwset)
                cur.executemany('INSERT OR IGNORE INTO passwd (passwd) VALUES (?)', [(pw,) for pw in pwset])
                self.tell("Wrote %i lines...\r" % i, end=None, sep=None)
            print "\nWriting ESSIDs and results..."
            for essid in essids:
                self.tell("Writing '%s'..." % essid)
                cur.execute('INSERT OR IGNORE INTO essid (essid) VALUES (?)', (essid,))
                essid_id = cur.execute('SELECT essid_id FROM essid WHERE essid = ?', (essid,)).fetchone()[0]
                i = 0
                for results in self.essidstore.iterresults(essid):
                    i += len(results)
                    cur.executemany('INSERT OR IGNORE INTO pmk (essid_id, passwd_id, pmk) SELECT ?, passwd_id, ? FROM passwd WHERE passwd = ?',
                                    ((essid_id, buffer(pmk), pw) for pw, pmk in results.iteritems()))
                    self.tell("Wrote %i lines...\r" % i, end=None, sep=None)
            print "\nAll done."
        except:
            con.rollback()
            self.tell("There was an error while exporting. The database has not been modified...", stream=sys.stderr)
            raise
        else:
            con.commit()
        finally:
            cur.close()
            con.close()

    def batchprocess(self):
        import cpyrit
        cp = cpyrit.CPyrit()

        def _writeCowpatty(out, results):
            if self.options.file == '-':
                try:
                    out.write(util.genCowpEntries(results.iteritems()))
                except IOError:
                    self.tell("IOError while writing to stdout. Batchprocessing continues silently...", stream=sys.stderr)
                    self.options.file = ''                        
        
        if self.options.file == "-" and self.options.essid is None:
            self.tell("Results will be written to stdout while batchprocessing. This requires to specify a ESSID.", stream=sys.stderr) 
            return
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = list(self.essidstore)
        
        totalResCount = 0
        startTime = time.time()
        workunits = []
        awriter = util.AsyncFileWriter(sys.stdout) 
        try: 
            for essid in essids:
                self.tell("Working on ESSID '%s'" % essid)
                if self.options.file == "-":
                    awriter.write(util.genCowpHeader(essid))
                for key in self.passwdstore:
                    passwords = self.passwdstore[key]
                    results = self.essidstore[essid, key]
                    if len(results) < len(passwords):
                        workunits.append((essid, key, passwords))
                        cp.enqueue(essid, passwords, True)
                    else:
                        _writeCowpatty(awriter, results)
                    solvedPMKs = cp.dequeue(block=False)
                    if solvedPMKs is not None:
                        solvedEssid, solvedKey, solvedPasswords = workunits.pop(0)
                        solvedResults = dict(itertools.izip(solvedPasswords, solvedPMKs))
                        self.essidstore[solvedEssid, solvedKey] = solvedResults
                        totalResCount += len(solvedResults)
                        _writeCowpatty(awriter, solvedResults)
                    tdiff = time.time() - startTime
                    self.tell("Computed %i PMKs in %i seconds; %i PMKs per second.\r" % (totalResCount, tdiff, totalResCount / tdiff), end=None, sep=None)
                self.tell("")
            self.tell("Stopped reading workunits...")
            for solvedPMKs in cp:
                solvedEssid, solvedKey, solvedPasswords = workunits.pop(0)
                solvedResults = dict(itertools.izip(solvedPasswords, solvedPMKs))
                self.essidstore[solvedEssid, solvedKey] = solvedResults
                totalResCount += len(solvedResults)
                _writeCowpatty(awriter, solvedResults)
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        finally:
            awriter.close()
            if totalResCount > 0:   
                tdiff = time.time() - startTime
                self.tell("\nAll done. %.2f PMKs/s total." % (totalResCount / tdiff))
                for core in cp.cores:
                    resCount, compTime = core.getStats()
                    self.tell("%s: %.2f PMKs/s, (%.2f%% occupancy)" % (core.name, (resCount / compTime) if compTime > 0 else 0 , compTime * 100.0 / tdiff))
        self.tell("Batchprocessing done.")

    def benchmark(self):
        import cpyrit
        cp = cpyrit.CPyrit(maxBufferSize=10000)
        self.tell("Running benchmark for at least 60 seconds...\n")
        t = time.time()
        pws = ['barbarbar']*3500
        while time.time() - t < 60:
            cp.enqueue('foo', pws, block=True)
            while True:
                r = cp.dequeue(block=False)
                if not r:
                    break
        for r in cp:
            pass
        total = 0
        tdiff = time.time() - t
        for core in cp.cores:
            resCount, compTime = core.getStats()
            perf = resCount / compTime if compTime > 0 else 0
            self.tell("%s: %.2f PMKs/s (%.2f%% occupancy)" % (core.name, perf, compTime * 100.0 / tdiff))
            total += perf
        self.tell("\nBenchmark done. %.2f PMKs/s total." % total)

    def selftest(self):
        import cpyrit
        cp = cpyrit.CPyrit(maxBufferSize=10000)
        self.tell("Cores incorporated in the test:")
        for i, core in enumerate(cp.cores):
            self.tell("#%i:  '%s'" % (i+1, core))
        self.tell("\nRunning selftest for at least 60 seconds...")
        workunits = []
        t = time.time()
        err = False
        while time.time() - t < 60 and not err:
            essid = random.choice(util.PMK_TESTVECTORS.keys())
            pws = [random.choice(util.PMK_TESTVECTORS[essid].keys()) for i in xrange(random.randrange(10, 500))]
            workunits.append((essid, pws))
            cp.enqueue(essid, pws, block=True)
            while True:
                solvedPMKs = cp.dequeue(block=False)
                if solvedPMKs is not None:
                    essid, pws = workunits.pop(0)
                    if [util.PMK_TESTVECTORS[essid][pw] for pw in pws] != list(solvedPMKs):
                        err = True
                        break
                if err or not solvedPMKs:
                    break
        if not err:
            for solvedPMKs in cp:
                essid, pws = workunits.pop(0)
                if [util.PMK_TESTVECTORS[essid][pw] for pw in pws] != list(solvedPMKs):
                    err = True
                    break
        if err or len(workunits) != 0 or len(cp) != 0:
            self.tell("\n!!! WARNING !!!\n"\
                      "At least some results are definitly invalid."\
                      "This may be caused by a bug in Pyrit, faulty hardware or malicious network clients. Do not trust this installation...\n",
                      stream=sys.stderr)
        else:
            self.tell("\nAll results verified. Your installation seems OK.")
    
    def verify(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = list(self.essidstore)
        totalResCount = 0
        err = False
        startTime = time.time()
        workunits = []
        try: 
            for essid in essids:
                self.tell("Verifying ESSID '%s'" % essid)
                for key in self.essidstore.iterkeys(essid):
                    results = self.essidstore[essid, key]
                    pws = random.sample(results, int(len(results) * 0.1))
                    if len(pws) > 0:
                        workunits.append((essid, key, tuple([results[pw] for pw in pws])))
                        cp.enqueue(essid, pws, True)
                    solvedPMKs = cp.dequeue(block=False)
                    if solvedPMKs is not None:
                        totalResCount += len(solvedPMKs)
                        testedEssid, testedKey, testedPMKs = workunits.pop(0)
                        if testedPMKs != solvedPMKs:
                            self.tell("Workunit %s for ESSID '%s' seems corrupted." % (testedKey, testedEssid), stream=sys.stderr)
                            err = True
                    tdiff = time.time() - startTime
                    self.tell("Computed %i PMKs in %i seconds; %i PMKs per second.\r" % (totalResCount, tdiff, totalResCount / tdiff), end=None, sep=None)
                for solvedPMKs in cp:
                    totalResCount += len(solvedPMKs)
                    testedEssid, testedKey, testedPMKs = workunits.pop(0)
                    if testedPMKs != solvedPMKs:
                        self.tell("Workunit %s for ESSID '%s' seems corrupted." % (testedKey, testedEssid), stream=sys.stderr)
                        err = True
            self.tell("\nVerified %i PMKs with %.2f PMKs/s." % (totalResCount, totalResCount / (time.time() - startTime)))
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        if err:
            self.tell("\nAt least one workunit-file contains invalid results. There are two options now:\n"
                      "* The results on the disk are really invalid. You should mistrust the entire repository but at least delete and recompute the offending ESSIDs.\n"
                      "* The result on the disk are correct but your installation is broken and currently computes invalid results.\n"
                      "Run 'selftest' for an extensive self-test in order to tell the two options apart.",
                      stream=sys.stderr)
        else:
            self.tell("Everything seems OK.")

    def serve(self):
        self.tell('Booting...', end=None)
        httpd = PyritServer()
        self.tell('%s, %i cores:' % (httpd.name, len(httpd.cp.cores)))
        for i, core in enumerate(httpd.cp.cores):
            self.tell("#%i '%s'" % (i+1, core))
        try:
            httpd.serve_forever()
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")


class PyritServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    class PyritHandler(BaseHTTPServer.BaseHTTPRequestHandler):
        def do_GET(self):
            self.parsed_path = urlparse.urlparse(self.path)
            self.params = {}
            if len(self.parsed_path.query) > 0:
                self.params.update([x.split('=') for x in self.parsed_path.query.split("&")])

            if self.parsed_path.path == "/":
                self.send_response(httplib.OK)
                self.end_headers()
                self.wfile.write('%s, started %s\n\nActive cores:\n' % (self.server.name, time.ctime(self.server.started)))
                for i, core in enumerate(self.server.cp.cores):
                    self.wfile.write(" #%i '%s', did %i PMKs so far\n" % (i, core, core.getStats()[0]))
                self.wfile.write('\nActive clients:\n')
                for i, (name, joined, lastseen, inCount, outCount) in enumerate(self.server.getClientStats()):
                    self.wfile.write(" #%i '%s'\n  Joined %s, last seen %s\n  %i passwords queued, %i processed\n\n" %
                                        (i, name, time.ctime(joined), time.ctime(lastseen), inCount, outCount))

            elif self.parsed_path.path == "/ENQUEUE":
                if 'client' not in self.params or self.params['client'] not in self.server.clients:
                    self.send_response(httplib.FORBIDDEN)
                    self.end_headers()
                else:
                    buf = self.rfile.read(int(self.headers.getheader('Content-Length')))
                    digest = hashlib.sha1()
                    essid, pwbuffer = buf[digest.digest_size:].split('\n', 1)
                    digest.update(essid)
                    digest.update(pwbuffer)
                    if digest.digest() != buf[:digest.digest_size]:
                        raise Exception, "Digest check failed."
                    self.server.enqueue(self.params['client'], essid, pwbuffer.split('\n'))
                    self.send_response(httplib.OK)
                    self.end_headers()
                    self.wfile.write(str(len(self.server)))

            elif self.parsed_path.path == "/DEQUEUE":
                if 'client' not in self.params or self.params['client'] not in self.server.clients:
                    self.send_response(httplib.FORBIDDEN)
                    self.end_headers()
                else:
                    t = time.time()
                    while True:
                        res = self.server.dequeue(self.params['client'])
                        if res is not None or time.time() - t > 3.0:
                            break
                        else:
                            time.sleep(0.1)
                    if res is None:
                        self.send_response(httplib.PROCESSING)
                        self.end_headers()
                    else:
                        buf = ''.join(res)
                        digest = hashlib.sha1()
                        digest.update(buf)
                        self.send_response(httplib.OK)
                        self.end_headers()
                        self.wfile.write(digest.digest())
                        self.wfile.write(buf)

            elif self.parsed_path.path == "/REGISTER":
                client = self.server.registerClient(self.client_address[0])
                self.send_response(httplib.OK)
                self.end_headers()
                self.wfile.write(client.uuid)

            else:
                self.send_response(httplib.NOT_FOUND)
                self.end_headers()
        do_POST = do_GET

    class PyritServerCleaner(threading.Thread):
        def __init__(self, server):
            threading.Thread.__init__(self)
            self.server = server
            self.setDaemon(True)
            self.start()
            
        def run(self):
            while True:
                self.server.cv.acquire()
                try:
                    for client_uuid, client in self.server.clients.items():
                        if time.time() - client.lastseen > 60:
                            del self.server.clients[client_uuid]
                finally:
                    self.server.cv.release()
                time.sleep(15)

    class PyritClient(object):
        def __init__(self, host):
            self.host = host
            self.uuid = str(uuid.uuid4())
            self.joined = self.lastseen = time.time()
            self.inCount = self.outCount = 0
            self.outQueue = []
            
        def __repr__(self):
            return '%s@%s' % (self.host, self.uuid)

    def __init__(self):
        BaseHTTPServer.HTTPServer.__init__(self, ('', 19935), PyritServer.PyritHandler)
        import cpyrit
        self.cp = cpyrit.CPyrit()
        self.started = time.time()
        self.clients = {}
        self.wu_clients = []
        self.cv = threading.Condition()
        self.name = "Pyrit %s" % util.VERSION
        self.cleaner = PyritServer.PyritServerCleaner(self)

    def registerClient(self, host):
        self.cv.acquire()
        try:
            client = PyritServer.PyritClient(host)
            self.clients[client.uuid] = client
            return client
        finally:
            self.cv.release()
    
    def getClientStats(self):
        self.cv.acquire()
        try:
            return tuple([(str(c), c.joined, c.lastseen, c.inCount, c.outCount) for c in self.clients.itervalues()])
        finally:
            self.cv.release()

    def enqueue(self, client_uuid, essid, passwordlist):
        assert self.cleaner.isAlive()
        self.cv.acquire()
        try:
            if client_uuid not in self.clients:
                raise KeyError, "Client not registered"
            client = self.clients[client_uuid]
            self.cp.enqueue(essid, passwordlist, block=False)
            self.wu_clients.append(client_uuid)
            client.lastseen = time.time()
            client.inCount += len(passwordlist)
        finally:
            self.cv.release()
        
    def dequeue(self, client_uuid):
        assert self.cleaner.isAlive()
        self.cv.acquire()
        try:
            if client_uuid not in self.clients:
                raise KeyError, "Client not registered"
            while True:
                results = self.cp.dequeue(block=False)
                if results is None:
                    break
                else:
                    wu_client_uuid = self.wu_clients.pop(0)
                    if wu_client_uuid in self.clients:
                        wu_client = self.clients[wu_client_uuid]
                        wu_client.outQueue.append(results)
                        wu_client.outCount += len(results)
            client = self.clients[client_uuid]
            client.lastseen = time.time()
            if len(client.outQueue) > 0:
                return client.outQueue.pop(0)
            else:
                return None
        finally:
            self.cv.release() 

    def __len__(self):
        self.cv.acquire()
        try:
            return len(self.cp)
        finally:
            self.cv.release()


if __name__ == "__main__":
    Pyrit_CLI().init()

