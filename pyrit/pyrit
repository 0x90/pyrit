#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
#    Copyright 2008, 2009, Lukas Lueg, knabberknusperhaus@yahoo.de
#
#    This file is part of Pyrit.
#
#    Pyrit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Pyrit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Pyrit.  If not, see <http://www.gnu.org/licenses/>.

import BaseHTTPServer
import getopt
import hashlib
import httplib
import itertools
import os
import random
import re
import struct
import sys
import sqlite3
import SocketServer
import cStringIO
import threading
import time
import uuid
import urlparse
import zlib

from _cpyrit import _cpyrit_util as util

PMK_TESTVECTORS = {
    'foo': {
        'soZcEvntHVrGRDIxNaBCyUL': (247,210,173,42,68,187,144,253,145,93,126,250,16,188,100,55,89,153,135,155,198,86,124,33,45,16,9,54,113,194,159,211),
        'EVuYtpQCAZzBXyWNRGTI': (5,48,168,39,10,98,151,201,8,80,23,138,19,24,24,50,66,214,189,180,159,97,194,27,212,124,114,100,253,62,50,170),
        'XNuwoiGMnjlkxBHfhyRgZrJItFDqQVESm': (248,208,207,115,247,35,170,203,214,228,228,21,40,214,165,0,98,194,136,62,110,253,69,205,67,215,119,109,72,226,255,199),
        'bdzPWNTaIol': (228,236,73,0,189,244,21,141,84,247,3,144,2,164,99,205,37,72,218,202,182,246,227,84,24,58,147,114,206,221,40,127),
        'nwUaVYhRbvsH': (137,21,14,210,213,68,210,123,35,143,108,57,196,47,62,161,150,35,165,197,154,61,76,14,212,88,125,234,51,38,159,208),
        'gfeuvPBbaDrQHldZzRtXykjFWwAhS': (88,127,99,35,137,177,147,161,244,32,197,233,178,1,96,247,5,109,163,250,35,222,188,143,155,70,106,1,253,79,109,135),
        'QcbpRkAJerVqHz': (158,124,37,190,197,150,225,165,3,34,104,147,107,253,233,127,33,239,75,11,169,187,127,171,187,165,166,187,95,107,137,212),
        'EbYJsCNiwXDmHtgkFVacuOv': (136,5,34,189,145,60,145,54,179,198,195,223,34,180,144,3,116,102,39,134,68,82,210,185,190,199,36,25,136,152,0,111),
        'GpIMrFZwLcqyt': (28,144,175,10,200,46,253,227,219,35,98,208,220,11,101,95,62,244,80,221,111,49,206,255,174,100,240,240,33,229,172,207),
        'tKxgswlaOMLeZVScGDW': (237,62,117,60,38,107,65,166,113,174,196,221,128,227,69,89,23,77,119,234,41,176,145,105,92,40,157,151,229,50,81,65)
        },
    'bar': {
        'zLwSfveNskZoR': (38,93,196,77,112,65,163,197,249,158,180,107,231,140,188,60,254,77,12,210,77,185,233,59,79,212,222,181,44,19,127,220),
        'lxsvOCeZXop': (91,39,98,36,82,2,162,106,12,244,4,113,155,120,131,133,11,209,12,12,240,213,203,156,129,148,28,64,31,61,162,13),
        'tfHrgLLOA': (110,72,123,80,222,233,150,54,40,99,205,155,177,157,174,172,87,11,247,164,87,85,136,165,21,107,93,212,71,133,145,211),
        'vBgsaSJrlqajUlQJM': (113,110,180,150,204,221,61,202,238,142,147,118,177,196,65,79,102,47,179,80,175,95,251,35,227,220,47,121,50,125,55,16),
        'daDIHwIMKSUaKWXS': (33,87,211,99,26,70,123,19,254,229,148,97,252,182,3,44,228,125,85,141,247,223,166,133,246,37,204,145,100,218,66,70),
        'agHOeAjOpK': (226,163,62,215,250,63,6,32,130,34,117,116,189,178,245,172,74,26,138,10,106,119,15,214,210,114,51,94,254,57,81,200),
        'vRfEagJIzSohxsakj': (61,71,159,35,233,27,138,30,228,121,38,201,57,83,192,211,248,207,149,12,147,70,190,216,52,14,165,190,226,180,62,210),
        'PuDomzkiwsejblaXs': (227,164,137,231,16,31,222,169,134,1,238,190,55,126,255,88,178,118,148,119,244,130,183,219,124,249,194,96,94,159,163,185),
        'RErvpNrOsW': (24,145,197,137,14,154,1,36,73,148,9,192,138,157,164,81,47,184,41,75,225,34,71,153,59,253,127,179,242,193,246,177),
        'ipptbpKkCCep': (81,34,253,39,124,19,234,163,32,10,104,88,249,29,40,142,24,173,1,68,187,212,21,189,74,88,83,228,7,100,23,244)
        }
    }

class AsyncFileWriter(threading.Thread):
    def __init__(self, filehndl, maxsize=10*1024**2):
        threading.Thread.__init__(self)
        self.shallstop = False
        self.filehndl = filehndl
        self.maxsize = maxsize
        self.excp = None
        self.buf = cStringIO.StringIO()
        self.cv = threading.Condition()
        self.start()
        
    def close(self):
        self.cv.acquire()
        try:
            self.shallstop = True
            self.cv.notifyAll()
            while self.isAlive():
                self.cv.wait()
            self._raise
        finally:
            self.cv.release()

    def write(self, data):
        self.cv.acquire()
        try:
            self._raise()
            while self.buf.tell() > self.maxsize and not self.shallstop:
                self.cv.wait()
                if self.shallstop:
                    raise Exception, "Writer has already been closed."
            self.buf.write(data)
            self.cv.notifyAll()
        finally:
            self.cv.release()

    def _raise(self):
        if self.excp:
            e = self.excp
            self.excp = None
            self.shallstop = True
            self.cv.notifyAll()
            raise type(e)(str(e))

    def run(self):
        try:
            while self.buf.tell() > 0 or not self.shallstop:
                self.cv.acquire()
                try:
                    while self.buf.tell() == 0 and not self.shallstop:
                        self.cv.wait()
                    data = self.buf.getvalue()
                    self.buf = cStringIO.StringIO()
                    self.cv.notifyAll()
                finally:
                    self.cv.release()
                self.filehndl.write(data)
        except Exception, e:
            self.shallstop = True
            self.excp = e
        finally:
            self.cv.acquire()
            self.cv.notifyAll()
            self.cv.release()


class Pyrit_CLI(object):
    class options(object):
        def __init__(self):
            self.essidstore_path = os.path.expanduser(os.path.join('~','.pyrit','blobspace','essid'))
            self.passwdstore_path = os.path.expanduser(os.path.join('~','.pyrit','blobspace','password'))
            self.essid = None
            self.file = None
            self.verbose = True

    def __init__(self):
        # I *hate* the lookup syntax in the code further below if options is a dict
        self.options = self.options()
        
    def tell(self, text, sep=' ', end='\n', stream=sys.stdout, flush=False):
        if self.options.verbose or stream != sys.stdout:
            stream.write(text)
            if end is not None:
                stream.write(end)
            else:
                if sep is not None:
                    stream.write(sep)
            if flush or end is None:
                stream.flush()
        
    def init(self):
        options, commands = getopt.getopt(sys.argv[1:], "u:v:c:e:f:")
        for option, value in dict(options).items():
            if option == '-e':
                self.options.essid = value
            elif option == '-f':
                self.options.file = value
            else:
                self.tell("Option '%s' not known. Ignoring..." % option)
        if self.options.file == "-" or 'passthrough' in commands:
            self.options.verbose = False

        self.essidstore = EssidStore(self.options.essidstore_path)
        self.passwdstore = PasswordStore(self.options.passwdstore_path)

        self.tell("Pyrit 0.2.3-dev (C) 2008, 2009 Lukas Lueg http://pyrit.googlecode.com" \
                "\nThis code is distributed under the GNU General Public License v3\n")
        if len(self.essidstore) == 0 and len(commands) > 0 and commands[0] != "create_essid":
            self.tell("The ESSID-blobspace seems to be empty; you should create an ESSID...\n", stream=sys.stderr)

        {'export_cowpatty': self.export_cowpatty,
        'export_hashdb': self.export_hashdb,
        'export_passwords': self.export_passwords,
        'import_passwords': self.import_passwords,
        'list_cores': self.list_cores,
        'list_essids': self.list_essids,
        'create_essid': self.create_essid,
        'delete_essid': self.delete_essid,
        'eval': self.eval_results,
        'batch': self.batchprocess,
        'batchprocess': self.batchprocess,
        'passthrough': self.passthrough,
        'benchmark': self.benchmark,
        'serve': self.serve,
        'selftest': self.selftest,
        'verify': self.verify,
        'help': self.print_help
        }.setdefault(commands[0] if len(commands) > 0 else 'help', self.print_help)()

    def print_help(self):
        self.tell("Usage: pyrit [options] command " \
            "\n\nRecognized options:" \
            "\n  -e    : ESSID for the command" \
            "\n  -f    : filename for the command ('-' is stdin/stdout)" \
            "\n\nRecognized commands:" \
            "\n  batch            : Batchprocess" \
            "\n  benchmark        : Determine performance of available cores" \
            "\n  create_essid     : Create a new ESSID" \
            "\n  delete_essid     : Delete a ESSID and corresponding results" \
            "\n  eval             : Count the available passwords and matching results" \
            "\n  export_cowpatty  : Export into a new cowpatty file" \
            "\n  export_hashdb    : Export into an airolib database" \
            "\n  import_passwords : Import passwords" \
            "\n  list_cores       : List available cores" \
            "\n  list_essids      : List all ESSIDs but don't count matching results" \
            "\n  passthrough      : Compute PMKs on the fly and write to stdout" \
            "\n  serve            : Serve requests from clients on the network" \
            "\n  selftest         : Test all cores for computing correct results" \
            "\n  verify           : Verify 10% of the results through recomputation" \
            "\n")

    def create_essid(self):
        if self.options.essid is None:
            self.tell("You must specify a ESSID using the -e option. See 'help'.", stream=sys.stderr)
        elif self.options.essid in self.essidstore:
            self.tell("ESSID already created", stream=sys.stderr)
        else:
            self.essidstore.create_essid(self.options.essid)
            self.tell("Created ESSID '%s'" % self.options.essid)

    def delete_essid(self):
        if self.options.essid is None:
            self.tell("You must specify a ESSID using the -e option. See 'help'.", stream=sys.stderr)
        elif self.options.essid not in self.essidstore:
            self.tell("ESSID not found...", stream=sys.stderr)
        else:
            self.tell("All results for ESSID '%s' will be deleted! Continue? [y/N]" % self.options.essid, end=None)
            if sys.stdin.readline().strip() == 'y':
                self.tell("deleting...")
                self.essidstore.delete_essid(self.options.essid)
                self.tell("Deleted ESSID '%s'." % self.options.essid)
            else:
                self.tell("aborted.")

    def list_cores(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        self.tell("The following cores seem available...")
        for i, corename in enumerate(cp.availableCores()):
            self.tell("#%i:  '%s'" % (i+1, corename))

    def list_essids(self):
        self.tell("Listing ESSIDs...")
        for i, essid in enumerate(self.essidstore):
            self.tell("#%i:  '%s'" % (i, essid))

    def eval_results(self):
        essid_results = dict.fromkeys(self.essidstore, 0)
        pwcount = 0
        for key in self.passwdstore:
            pwcount += len(self.passwdstore[key])
            self.tell("Passwords available:\t%i\r" % pwcount, end=None, sep=None)
            for essid in essid_results:
                essid_results[essid] += len(self.essidstore[essid, key])
        self.tell("Passwords available:\t%i\n" % pwcount)
        for essid, rescount in sorted(essid_results.iteritems()):
            self.tell("ESSID '%s':\t%i (%.2f%%)" % (essid, rescount, (rescount * 100.0 / pwcount) if pwcount > 0 else 0.0))
        self.tell("")
            
    def import_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
        else:
            self.tell("Importing from ", end=None)
            if self.options.file == "-":
                self.tell("stdin.")
                f = sys.stdin
            else:
                self.tell("'%s'" % self.options.file)
                f = open(self.options.file, "r")
            for i, line in enumerate(f):
                self.passwdstore.store_password(line)
                if i % 100000 == 0:
                    self.tell("\r%i lines read." % i, end=None, flush=True)
            f.close()
            self.tell("\r%i lines read. Flushing buffers..." % (i + 1))
            self.passwdstore.flush_buffer()
            self.tell("All done.")

    def export_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.file == '-':
            f = sys.stdout
        else:
            self.tell("Exporting to '%s'..." % self.options.file)
            f = open(self.options.file, 'wb')
        lines = 0
        awriter = AsyncFileWriter(f)
        try:
            for pwset in self.passwdstore.iterpasswords():
                awriter.write('\n'.join(pwset))
                awriter.write('\n')
                lines += len(pwset)
                self.tell("%i lines written\r" % lines, end=None, sep=None)
            self.tell("\nAll done")
        finally:
            awriter.close()
            f.close()
    
    def export_cowpatty(self):
        if self.options.file is None:
            self.tell("You must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.essid is None:
            essid = self.options.file.split('.')[0]
            if essid in self.essidstore:
                self.options.essid = essid
            else:
                self.tell("The cowpatty-format only supports one ESSID per file. Please specify one using the -e option.", stream=sys.stderr)
                return
        f = sys.stdout if self.options.file == '-' else open(self.options.file, 'wb')
        lines = 0
        self.tell("Exporting to '%s'..." % self.options.file)
        awriter = AsyncFileWriter(f)
        try:
            awriter.write(util.genCowpHeader(self.options.essid))
            for results in self.essidstore.iterresults(self.options.essid):
                awriter.write(util.genCowpEntries(results.items()))
                lines += len(results)
                self.tell("\r%i entries written..." % lines, end=None, sep=None)
            self.tell("\r%i entries written. All done." % lines)
        except IOError:
            self.tell("IOError while exporting to stdout ignored...", stream=sys.stderr)
        finally:
            awriter.close()
            f.close()

    def passthrough(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        if self.options.essid is None:
            self.tell("Specifiy a ESSID using the -e option. See 'help'", stream=sys.stderr)
            return
        if self.options.file is None:
            self.tell("Specify a filename using the -f option to read passwords from. See 'help'", stream=sys.stderr)
            return
        f = sys.stdin if self.options.file == '-' else open(self.options.file, 'r')
        awriter = AsyncFileWriter(sys.stdout)       
        try:
            awriter.write(util.genCowpHeader(self.options.essid))
            workunits = []
            pwbuffer = set()
            for line in f:
                pw = line.strip()[:63]
                if len(pw) >= 8:
                    pwbuffer.add(pw)
                if len(pwbuffer) > 20000:
                    workunits.append(pwbuffer)
                    cp.enqueue(self.options.essid, workunits[-1], True)
                    pwbuffer = set()
                    while True:
                        solvedPMKs = cp.dequeue(block=False)
                        if solvedPMKs is not None:
                            awriter.write(util.genCowpEntries(itertools.izip(workunits.pop(0), solvedPMKs)))
                        else:
                            break
            if len(pwbuffer) > 0:
                workunits.append(pwbuffer)
                cp.enqueue(self.options.essid, workunits[-1], True)
            for solvedPMKs in cp:
                awriter.write(util.genCowpEntries(itertools.izip(workunits.pop(0), solvedPMKs)))
        except IOError:
            self.tell("IOError while writing to stdout ignored...", stream=sys.stderr)
        finally:
            awriter.close()
            f.close()

    def export_hashdb(self):
        if self.options.file is None:
            self.tell("You must specify the database filename using the -f option. See 'help'", stream=sys.stderr)
            return
        essids = list(self.essidstore) if self.options.essid is None else [self.options.essid]

        con = sqlite3.connect(self.options.file)
        con.text_factory = str
        cur = con.cursor()
        cur.execute('SELECT * FROM sqlite_master')
        tbls = [x[1] for x in cur.fetchall() if x[0] == u'table']
        if u'pmk' not in tbls or u'essid' not in tbls or u'passwd' not in tbls:
            self.tell("The database '%s' seems to be uninitialized. "  % self.options.file +
                      "Trying to create default table-layout...", end=None)
            try:
                cur.execute("CREATE TABLE essid (essid_id INTEGER PRIMARY KEY AUTOINCREMENT, essid TEXT, prio INTEGER DEFAULT 64)")
                cur.execute("CREATE TABLE passwd (passwd_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd TEXT)")
                cur.execute("CREATE TABLE pmk (pmk_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd_id INT, essid_id INT, pmk BLOB)")
                cur.execute("CREATE TABLE workbench (wb_id INTEGER PRIMARY KEY AUTOINCREMENT, essid_id INT, passwd_id INT, lockid INTEGER DEFAULT 0)")
                cur.execute("CREATE INDEX lock_lockid ON workbench (lockid);")
                cur.execute("CREATE UNIQUE INDEX essid_u ON essid (essid)")
                cur.execute("CREATE UNIQUE INDEX passwd_u ON passwd (passwd)")
                cur.execute("CREATE UNIQUE INDEX ep_u ON pmk (essid_id, passwd_id)")
                cur.execute("CREATE UNIQUE INDEX wb_u ON workbench (essid_id, passwd_id)")
                cur.execute("CREATE TRIGGER delete_essid DELETE ON essid BEGIN DELETE FROM pmk WHERE pmk.essid_id = OLD.essid_id; DELETE FROM workbench WHERE workbench.essid_id = OLD.essid_id; END;")
                cur.execute("CREATE TRIGGER delete_passwd DELETE ON passwd BEGIN DELETE FROM pmk WHERE pmk.passwd_id = OLD.passwd_id; DELETE FROM workbench WHERE workbench.passwd_id = OLD.passwd_id; END;")
                self.tell("Tables created...")
            except:
                con.rollback()
                cur.close()
                con.close()
                self.tell("Failed to initialize the database:", stream=sys.stderr)
                raise
        try:
            cur.execute("PRAGMA synchronous = 1")
            i = 0
            print "Writing passwords..."
            for pwset in self.passwdstore.iterpasswords():
                i += len(pwset)
                cur.executemany('INSERT OR IGNORE INTO passwd (passwd) VALUES (?)', [(pw,) for pw in pwset])
                self.tell("Wrote %i lines...\r" % i, end=None, sep=None)
            print "\nWriting ESSIDs and results..."
            for essid in essids:
                self.tell("Writing '%s'..." % essid)
                cur.execute('INSERT OR IGNORE INTO essid (essid) VALUES (?)', (essid,))
                essid_id = cur.execute('SELECT essid_id FROM essid WHERE essid = ?', (essid,)).fetchone()[0]
                i = 0
                for results in self.essidstore.iterresults(essid):
                    i += len(results)
                    cur.executemany('INSERT OR IGNORE INTO pmk (essid_id, passwd_id, pmk) SELECT ?, passwd_id, ? FROM passwd WHERE passwd = ?',
                                    ((essid_id, buffer(pmk), pw) for pw, pmk in results.iteritems()))
                    self.tell("Wrote %i lines...\r" % i, end=None, sep=None)
            print "\nAll done."
        except:
            con.rollback()
            self.tell("There was an error while exporting. The database has not been modified...", stream=sys.stderr)
            raise
        else:
            con.commit()
        finally:
            cur.close()
            con.close()

    def batchprocess(self):
        import cpyrit
        cp = cpyrit.CPyrit()

        def _writeCowpatty(out, results):
            if self.options.file == '-':
                try:
                    out.write(util.genCowpEntries(results.iteritems()))
                except IOError:
                    self.tell("IOError while writing to stdout. Batchprocessing continues silently...", stream=sys.stderr)
                    self.options.file = ''                        
        
        if self.options.file == "-" and self.options.essid is None:
            self.tell("Results will be written to stdout while batchprocessing. This requires to specify a ESSID.", stream=sys.stderr) 
            return
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = list(self.essidstore)
        
        totalResCount = 0
        startTime = time.time()
        workunits = []
        awriter = AsyncFileWriter(sys.stdout) 
        try: 
            for essid in essids:
                self.tell("Working on ESSID '%s'" % essid)
                if self.options.file == "-":
                    awriter.write(util.genCowpHeader(essid))
                for key in self.passwdstore:
                    passwords = self.passwdstore[key]
                    results = self.essidstore[essid, key]
                    if len(results) < len(passwords):
                        workunits.append((essid, key, passwords))
                        cp.enqueue(essid, passwords, True)
                    else:
                        _writeCowpatty(awriter, results)
                    solvedPMKs = cp.dequeue(block=False)
                    if solvedPMKs is not None:
                        solvedEssid, solvedKey, solvedPasswords = workunits.pop(0)
                        solvedResults = dict(itertools.izip(solvedPasswords, solvedPMKs))
                        self.essidstore[solvedEssid, solvedKey] = solvedResults
                        totalResCount += len(solvedResults)
                        _writeCowpatty(awriter, solvedResults)
                    tdiff = time.time() - startTime
                    self.tell("Computed %i PMKs in %i seconds; %i PMKs per second.\r" % (totalResCount, tdiff, totalResCount / tdiff), end=None, sep=None)
                self.tell("")
            self.tell("Stopped reading workunits...")
            for solvedPMKs in cp:
                solvedEssid, solvedKey, solvedPasswords = workunits.pop(0)
                solvedResults = dict(itertools.izip(solvedPasswords, solvedPMKs))
                self.essidstore[solvedEssid, solvedKey] = solvedResults
                totalResCount += len(solvedResults)
                _writeCowpatty(awriter, solvedResults)
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        finally:
            awriter.close()
            if totalResCount > 0:   
                tdiff = time.time() - startTime
                self.tell("\nAll done. %.2f PMKs/s total." % (totalResCount / tdiff))
                for core in cp.cores:
                    resCount, compTime = core.getStats()
                    self.tell("%s: %.2f PMKs/s, (%.2f%% occupancy)" % (core.name, (resCount / compTime) if compTime > 0 else 0 , compTime * 100.0 / tdiff))
        self.tell("Batchprocessing done.")

    def benchmark(self):
        import cpyrit
        cp = cpyrit.CPyrit(maxBufferSize=10000)
        self.tell("Running benchmark for at least 60 seconds...\n")
        t = time.time()
        pws = ['barbarbar']*3500
        while time.time() - t < 60:
            cp.enqueue('foo', pws, block=True)
            while True:
                r = cp.dequeue(block=False)
                if not r:
                    break
        for r in cp:
            pass
        total = 0
        tdiff = time.time() - t
        for core in cp.cores:
            resCount, compTime = core.getStats()
            perf = resCount / compTime if compTime > 0 else 0
            self.tell("%s: %.2f PMKs/s (%.2f%% occupancy)" % (core.name, perf, compTime * 100.0 / tdiff))
            total += perf
        self.tell("\nBenchmark done. %.2f PMKs/s total." % total)

    def selftest(self):
        import cpyrit
        cp = cpyrit.CPyrit(maxBufferSize=10000)
        self.tell("Cores incorporated in the test:")
        for i, core in enumerate(cp.cores):
            self.tell("#%i:  '%s'" % (i+1, core))
        self.tell("\nRunning selftest for at least 60 seconds...")
        workunits = []
        t = time.time()
        err = False
        while time.time() - t < 60 and not err:
            essid = random.choice(PMK_TESTVECTORS.keys())
            pws = [random.choice(PMK_TESTVECTORS[essid].keys()) for i in xrange(random.randrange(10, 500))]
            workunits.append((essid, pws))
            cp.enqueue(essid, pws, block=True)
            while True:
                solvedPMKs = cp.dequeue(block=False)
                if solvedPMKs is not None:
                    essid, pws = workunits.pop(0)
                    if [PMK_TESTVECTORS[essid][pw] for pw in pws] != [tuple(map(ord, pmk)) for pmk in solvedPMKs]:
                        err = True
                        break
                if err or not solvedPMKs:
                    break
        if not err:
            for solvedPMKs in cp:
                essid, pws = workunits.pop(0)
                if [PMK_TESTVECTORS[essid][pw] for pw in pws] != [tuple(map(ord, pmk)) for pmk in solvedPMKs]:
                    err = True
                    break
        if err or len(workunits) != 0 or len(cp) != 0:
            self.tell("\n!!! WARNING !!!\n"\
                      "At least some results are definitly invalid."\
                      "This may be caused by a bug in Pyrit, faulty hardware or malicious network clients. Do not trust this installation...\n",
                      stream=sys.stderr)
        else:
            self.tell("\nAll results verified. Your installation seems OK.")
    
    def verify(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = list(self.essidstore)
        totalResCount = 0
        err = False
        startTime = time.time()
        workunits = []
        try: 
            for essid in essids:
                self.tell("Verifying ESSID '%s'" % essid)
                for key in self.essidstore.iterkeys(essid):
                    results = self.essidstore[essid, key]
                    pws = random.sample(results, int(len(results) * 0.1))
                    if len(pws) > 0:
                        workunits.append((essid, key, tuple([results[pw] for pw in pws])))
                        cp.enqueue(essid, pws, True)
                    solvedPMKs = cp.dequeue(block=False)
                    if solvedPMKs is not None:
                        totalResCount += len(solvedPMKs)
                        testedEssid, testedKey, testedPMKs = workunits.pop(0)
                        if testedPMKs != solvedPMKs:
                            self.tell("Workunit %s for ESSID '%s' seems corrupted." % (testedKey, testedEssid), stream=sys.stderr)
                            err = True
                    tdiff = time.time() - startTime
                    self.tell("Computed %i PMKs in %i seconds; %i PMKs per second.\r" % (totalResCount, tdiff, totalResCount / tdiff), end=None, sep=None)
                for solvedPMKs in cp:
                    totalResCount += len(solvedPMKs)
                    testedEssid, testedKey, testedPMKs = workunits.pop(0)
                    if testedPMKs != solvedPMKs:
                        self.tell("Workunit %s for ESSID '%s' seems corrupted." % (testedKey, testedEssid), stream=sys.stderr)
                        err = True
            self.tell("\nVerified %i PMKs with %.2f PMKs/s." % (totalResCount, totalResCount / (time.time() - startTime)))
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        if err:
            self.tell("\nAt least one workunit-file contains invalid results. There are two options now:\n"
                      "* The results on the disk are really invalid. You should mistrust the entire repository but at least delete and recompute the offending ESSIDs.\n"
                      "* The result on the disk are correct but your installation is broken and currently computes invalid results.\n"
                      "Run 'selftest' for an extensive self-test in order to tell the two options apart.",
                      stream=sys.stderr)
        else:
            self.tell("Everything seems OK.")

    def serve(self):
        self.tell('Booting...', end=None)
        httpd = PyritServer()
        self.tell('%s, %i cores:' % (httpd.name, len(httpd.cp.cores)))
        for i, core in enumerate(httpd.cp.cores):
            self.tell("#%i '%s'" % (i+1, core))
        try:
            httpd.serve_forever()
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")


class EssidStore(object):
    _pyr_preheadfmt = '<4sH'
    _pyr_preheadfmt_size = struct.calcsize(_pyr_preheadfmt)
    def __init__(self, basepath):
        self.basepath = basepath
        if not os.path.exists(self.basepath):
            os.makedirs(self.basepath)

    def _getessidroot(self, essid):
        return os.path.join(self.basepath, hashlib.md5(essid).hexdigest()[:8])

    def __getitem__(self, (essid, key)):
        essidpath = self._getessidroot(essid)
        if not os.path.exists(essidpath):
            raise KeyError, "ESSID not in store."
        filename = os.path.join(essidpath, key) + '.pyr'
        if not os.path.exists(filename):
            return {}
        f = open(filename, 'rb')
        buf = f.read()
        f.close()
        if len(buf) == 0:
            return {}
        md = hashlib.md5()
        magic, essidlen = struct.unpack(EssidStore._pyr_preheadfmt, buf[:EssidStore._pyr_preheadfmt_size])
        if magic == 'PYR2':
            headfmt = "<%ssi%ss" % (essidlen, md.digest_size)
            headsize = struct.calcsize(headfmt)
            file_essid, numElems, digest = struct.unpack(headfmt, buf[EssidStore._pyr_preheadfmt_size:EssidStore._pyr_preheadfmt_size+headsize])
            if file_essid != essid:
                raise IOError, "ESSID in result-file mismatches."
            pmkoffset = EssidStore._pyr_preheadfmt_size + headsize
            pwoffset = pmkoffset + numElems * 32
            md.update(file_essid)
            md.update(buf[pmkoffset:])
            if md.digest() != digest:
                raise IOError, "Digest check failed on result-file '%s'." % filename
            results = dict(itertools.izip(
                           zlib.decompress(buf[pwoffset:]).split('\n'),
                           [buf[pmkoffset + i*32:pmkoffset + i*32 + 32] for i in xrange(numElems)]
                           ))
        else:
            raise IOError, "Not a PYR2-file."
        if len(results) != numElems:
            raise IOError, "Header announced %i results but %i unpacked" % (numElems, len(results))
        return results
    
    def __setitem__(self, (essid, key), results):
        essidpath = self._getessidroot(essid)
        if not os.path.exists(essidpath):
            raise KeyError, "ESSID not in store."
        filename = os.path.join(essidpath, key) + '.pyr'        
        pws, pmks = itertools.izip(*sorted(results.iteritems()))
        pwbuffer = zlib.compress('\n'.join(pws), 1)
        if hashlib.md5(pwbuffer).hexdigest() != key:
            raise ValueError, "Results and key mismatch."
        pmkbuffer = ''.join(pmks)
        md = hashlib.md5()
        md.update(essid)
        md.update(pmkbuffer)
        md.update(pwbuffer)
        f = open(filename, 'wb')
        f.write(struct.pack('<4sH%ssi%ss' % (len(essid), md.digest_size), 'PYR2', len(essid), essid, len(pws), md.digest()))
        f.write(pmkbuffer)
        f.write(pwbuffer)
        f.close()
        
    def __len__(self):
        return len([x for x in self])

    def __iter__(self):
        essids = set()
        for essid_hash in os.listdir(self.basepath):
            f = open(os.path.join(self.basepath, essid_hash, 'essid'), "rb")
            essid = f.read()
            f.close()
            if essid_hash == hashlib.md5(essid).hexdigest()[:8]:
                essids.add(essid)
            else:
                print >>sys.stderr, "ESSID %s seems to be corrupted." % essid_hash
        return sorted(essids).__iter__()
            
    def __contains__(self, key):
        essid_root = self._getessidroot(key)
        if os.path.exists(essid_root):
            f = open(os.path.join(essid_root, 'essid'), 'rb')
            essid = f.read()
            f.close()
            return essid == key
        else:
            return False

    def iterkeys(self, essid):
        essidpath = self._getessidroot(essid)
        if not os.path.exists(essidpath):
            raise KeyError, "ESSID not in store."
        keys = set()
        for pyrfile in os.listdir(essidpath):
            if pyrfile[-4:] != '.pyr':
                continue
            keys.add(pyrfile[:len(pyrfile)-4])
        return keys.__iter__()
        
    def iterresults(self, essid):
        for key in self.iterkeys(essid):
            yield self[essid, key]

    def create_essid(self, essid):
        if len(essid) < 3 or len(essid) > 32:
            raise ValueError, "ESSID invalid."
        essid_root = self._getessidroot(essid)
        if not os.path.exists(essid_root):
            os.makedirs(essid_root)
        f = open(os.path.join(essid_root, 'essid'), 'wb')
        f.write(essid)
        f.close()

    def delete_essid(self, essid):
        if essid not in self:
            raise KeyError, "ESSID not in store."
        essid_root = self._getessidroot(essid)
        for fname in os.listdir(essid_root):
            if fname[-4:] == '.pyr':
                os.unlink(os.path.join(essid_root, fname))
        os.unlink(os.path.join(essid_root, 'essid'))
        os.rmdir(essid_root)


class PasswordStore(object):
    h1_list = ["%02.2X" % i for i in xrange(256)]
    def __init__(self, basepath):
        self.basepath = basepath
        if not os.path.exists(self.basepath):
            os.makedirs(self.basepath)
        self.pwbuffer = {}
        self.pwfiles = {}
        for pw_h1 in os.listdir(self.basepath):
            if pw_h1 not in PasswordStore.h1_list:
                continue
            pwpath = os.path.join(self.basepath, pw_h1)
            for pwfile in os.listdir(pwpath):
                if pwfile[-3:] != '.pw':
                    continue
                self.pwfiles[pwfile[:len(pwfile)-3]] = pwpath

    def __contains__(self, key):
        return key in self.pwfiles

    def __iter__(self):
        return self.pwfiles.__iter__()

    def __getitem__(self, key):
        if key not in self:
            raise KeyError, "Key not in storage."
        filename = os.path.join(self.pwfiles[key], key) + ".pw"
        f = open(filename, "rb")
        buf = f.read()
        f.close()
        if len(buf) == 0:
            return frozenset()
        else:
            if buf[:4] == "PAW2":
                md = hashlib.md5()
                md.update(buf[4+md.digest_size:])
                if md.digest() != buf[4:4+md.digest_size]:
                    raise Exception, "Digest check failed for %s" % filename
                if md.hexdigest() != key:
                    raise Exception, "File '%s' doesn't match the key '%s'." % (filename, md.hexdigest())
                return frozenset(zlib.decompress(buf[4+md.digest_size:]).split('\n'))
            else:
                raise Exception, "'%s' is not a PasswordFile." % filename


    def _flush_bucket(self, pw_h1, bucket):
        if len(bucket) == 0:
            return
        for pwset in self:
            bucket.difference_update(pwset)
        if len(bucket) > 0:
            pwpath = os.path.join(self.basepath, pw_h1)
            if not os.path.exists(pwpath):
                os.makedirs(pwpath)
            md = hashlib.md5()
            b = zlib.compress('\n'.join(sorted(bucket)), 1)
            md.update(b)
            f = open(os.path.join(pwpath, md.hexdigest()) + '.pw', 'wb')
            f.write('PAW2')
            f.write(md.digest())
            f.write(b)
            f.close()
            self.pwfiles[md.hexdigest()] = pwpath
            
    def iterpasswords(self):
        for key in self:
            yield self[key]

    def flush_buffer(self):
        for pw_h1, pw_bucket in self.pwbuffer.iteritems():
            self._flush_bucket(pw_h1, pw_bucket)
            self.pwbuffer[pw_h1] = set()

    def store_password(self, passwd):
        passwd = passwd.strip()
        if len(passwd) < 8 or len(passwd) > 63:
            return
        pw_h1 = PasswordStore.h1_list[hash(passwd) & 0xFF]
        pw_bucket = self.pwbuffer.setdefault(pw_h1, set())
        pw_bucket.add(passwd)
        if len(pw_bucket) >= 10000:
            self._flush_bucket(pw_h1, pw_bucket)
            self.pwbuffer[pw_h1] = set()


class PyritServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    class PyritHandler(BaseHTTPServer.BaseHTTPRequestHandler):
        def do_GET(self):
            self.parsed_path = urlparse.urlparse(self.path)
            self.params = {}
            if len(self.parsed_path.query) > 0:
                self.params.update([x.split('=') for x in self.parsed_path.query.split("&")])

            if self.parsed_path.path == "/":
                self.send_response(httplib.OK)
                self.end_headers()
                self.wfile.write('%s, started %s\n\nActive cores:\n' % (self.server.name, time.ctime(self.server.started)))
                for i, core in enumerate(self.server.cp.cores):
                    self.wfile.write(" #%i '%s', did %i PMKs so far\n" % (i, core, core.getStats()[0]))
                self.wfile.write('\nActive clients:\n')
                for i, (name, joined, lastseen, inCount, outCount) in enumerate(self.server.getClientStats()):
                    self.wfile.write(" #%i '%s'\n  Joined %s, last seen %s\n  %i passwords queued, %i processed\n\n" %
                                        (i, name, time.ctime(joined), time.ctime(lastseen), inCount, outCount))

            elif self.parsed_path.path == "/ENQUEUE":
                if 'client' not in self.params or self.params['client'] not in self.server.clients:
                    self.send_response(httplib.FORBIDDEN)
                    self.end_headers()
                else:
                    buf = self.rfile.read(int(self.headers.getheader('Content-Length')))
                    digest = hashlib.sha1()
                    essid, pwbuffer = buf[digest.digest_size:].split('\n', 1)
                    digest.update(essid)
                    digest.update(pwbuffer)
                    if digest.digest() != buf[:digest.digest_size]:
                        raise Exception, "Digest check failed."
                    self.server.enqueue(self.params['client'], essid, pwbuffer.split('\n'))
                    self.send_response(httplib.OK)
                    self.end_headers()
                    self.wfile.write(str(len(self.server)))

            elif self.parsed_path.path == "/DEQUEUE":
                if 'client' not in self.params or self.params['client'] not in self.server.clients:
                    self.send_response(httplib.FORBIDDEN)
                    self.end_headers()
                else:
                    t = time.time()
                    while True:
                        res = self.server.dequeue(self.params['client'])
                        if res is not None or time.time() - t > 3.0:
                            break
                        else:
                            time.sleep(0.1)
                    if res is None:
                        self.send_response(httplib.PROCESSING)
                        self.end_headers()
                    else:
                        buf = ''.join(res)
                        digest = hashlib.sha1()
                        digest.update(buf)
                        self.send_response(httplib.OK)
                        self.end_headers()
                        self.wfile.write(digest.digest())
                        self.wfile.write(buf)

            elif self.parsed_path.path == "/REGISTER":
                client = self.server.registerClient(self.client_address[0])
                self.send_response(httplib.OK)
                self.end_headers()
                self.wfile.write(client.uuid)

            else:
                self.send_response(httplib.NOT_FOUND)
                self.end_headers()
        do_POST = do_GET

    class PyritServerCleaner(threading.Thread):
        def __init__(self, server):
            threading.Thread.__init__(self)
            self.server = server
            self.setDaemon(True)
            self.start()
            
        def run(self):
            while True:
                self.server.cv.acquire()
                try:
                    for client_uuid, client in self.server.clients.items():
                        if time.time() - client.lastseen > 60:
                            del self.server.clients[client_uuid]
                finally:
                    self.server.cv.release()
                time.sleep(15)

    class PyritClient(object):
        def __init__(self, host):
            self.host = host
            self.uuid = str(uuid.uuid4())
            self.joined = self.lastseen = time.time()
            self.inCount = self.outCount = 0
            self.outQueue = []
            
        def __repr__(self):
            return '%s@%s' % (self.host, self.uuid)

    def __init__(self):
        BaseHTTPServer.HTTPServer.__init__(self, ('', 19935), PyritServer.PyritHandler)
        import cpyrit
        self.cp = cpyrit.CPyrit()
        self.started = time.time()
        self.clients = {}
        self.wu_clients = []
        self.cv = threading.Condition()
        self.name = "Pyrit 0.2.3-dev"
        self.cleaner = PyritServer.PyritServerCleaner(self)

    def registerClient(self, host):
        self.cv.acquire()
        try:
            client = PyritServer.PyritClient(host)
            self.clients[client.uuid] = client
            return client
        finally:
            self.cv.release()
    
    def getClientStats(self):
        self.cv.acquire()
        try:
            return tuple([(str(c), c.joined, c.lastseen, c.inCount, c.outCount) for c in self.clients.itervalues()])
        finally:
            self.cv.release()

    def enqueue(self, client_uuid, essid, passwordlist):
        assert self.cleaner.isAlive()
        self.cv.acquire()
        try:
            if client_uuid not in self.clients:
                raise KeyError, "Client not registered"
            client = self.clients[client_uuid]
            self.cp.enqueue(essid, passwordlist, block=False)
            self.wu_clients.append(client_uuid)
            client.lastseen = time.time()
            client.inCount += len(passwordlist)
        finally:
            self.cv.release()
        
    def dequeue(self, client_uuid):
        assert self.cleaner.isAlive()
        self.cv.acquire()
        try:
            if client_uuid not in self.clients:
                raise KeyError, "Client not registered"
            while True:
                results = self.cp.dequeue(block=False)
                if results is None:
                    break
                else:
                    wu_client_uuid = self.wu_clients.pop(0)
                    if wu_client_uuid in self.clients:
                        wu_client = self.clients[wu_client_uuid]
                        wu_client.outQueue.append(results)
                        wu_client.outCount += len(results)
            client = self.clients[client_uuid]
            client.lastseen = time.time()
            if len(client.outQueue) > 0:
                return client.outQueue.pop(0)
            else:
                return None
        finally:
            self.cv.release() 

    def __len__(self):
        self.cv.acquire()
        try:
            return len(self.cp)
        finally:
            self.cv.release()

if __name__ == "__main__":
    Pyrit_CLI().init()

