#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
#    Copyright 2008, 2009, Lukas Lueg, knabberknusperhaus@yahoo.de
#
#    This file is part of Pyrit.
#
#    Pyrit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Pyrit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Pyrit.  If not, see <http://www.gnu.org/licenses/>.

import getopt, hashlib, itertools, os, random, re, struct, sys, sqlite3, StringIO, threading, time, zlib

class AsyncFileWriter(threading.Thread):
    def __init__(self, filehndl, maxsize=10*1024**2):
        threading.Thread.__init__(self)
        self.running = True
        self.filehndl = filehndl
        self.maxsize = maxsize
        self.excp = None
        self.buf = StringIO.StringIO()
        self.cv = threading.Condition()
        self.start()
        
    def close(self):
        self.cv.acquire()
        self.running = False
        while self.running:
            self.wait(0.5)
        self.cv.release()
        if self.excp:
            raise self.excp

    def write(self, buf):
        if not self.running:
            if self.excp:
                raise self.excp
            else:
                raise Exception, "Writer has already been closed."
        self.cv.acquire()
        while self.running and self.buf.len > self.maxsize:
            self.cv.wait(0.5)
        self.buf.write(buf)
        self.cv.notifyAll()
        self.cv.release()

    def _write(self, buf):
        try:
            if len(buf) > 0:
                self.filehndl.write(buf)
        except Exception, e:
            self.running = False
            self.excp = e

    def run(self):
        while self.running:
            self.cv.acquire()
            while self.running and self.buf.len == 0:
                self.cv.wait(0.5)
            buf = self.buf.getvalue()
            self.buf = StringIO.StringIO()
            self.cv.notifyAll()
            self.cv.release()
            self._write(buf)
        self.cv.acquire()
        buf = self.buf.getvalue()
        self.cv.release()
        self._write(buf)
        self.filehndl.flush()


class Pyrit_CLI(object):
    class options(object):
        def __init__(self):
            self.essidstore_path = os.path.expanduser(os.path.sep.join(('~','.pyrit','blobspace','essid')))
            self.passwdstore_path = os.path.expanduser(os.path.sep.join(('~','.pyrit','blobspace','password')))
            self.essid = None
            self.file = None
            self.verbose = True
    
    def __init__(self):
        # I *hate* the lookup syntax in the code further below if options is a dict
        self.options = self.options()
        
    def tell(self, text, sep=' ', end='\n', stream=sys.stdout, flush=False):
        if self.options.verbose or stream != sys.stdout:
            stream.write(text)
            if end is not None:
                stream.write(end)
            else:
                if sep is not None:
                    stream.write(sep)
            if flush or end is None:
                stream.flush()
        
    def init(self):
        options, commands = getopt.getopt(sys.argv[1:], "u:v:c:e:f:")
        for option, value in dict(options).items():
            if option == '-e':
                self.options.essid = value
            elif option == '-f':
                self.options.file = value
            else:
                self.tell("Option '%s' not known. Ignoring..." % option)
        if self.options.file == "-" or 'passthrough' in commands:
            self.options.verbose = False

        self.essidstore = EssidStore(self.options.essidstore_path)
        self.passwdstore = PasswordStore(self.options.passwdstore_path)

        self.tell("Pyrit 0.2.3 (C) 2008, 2009 Lukas Lueg http://pyrit.googlecode.com" \
                "\nThis code is distributed under the GNU General Public License v3\n")
        if len(self.essidstore) == 0 and len(commands) > 0 and commands[0] != "create_essid":
            self.tell("The ESSID-blobspace seems to be empty; you should create an ESSID...\n", stream=sys.stderr)

        {'export_cowpatty': self.export_cowpatty,
        'export_hashdb': self.export_hashdb,
        'export_passwords': self.export_passwords,
        'import_passwords': self.import_passwords,
        'list_cores': self.list_cores,
        'list_essids': self.list_essids,
        'create_essid': self.create_essid,
        'eval': self.eval_results,
        'batch': self.batchprocess,
        'batchprocess': self.batchprocess,
        'passthrough': self.passthrough,
        'benchmark': self.benchmark,
        'help': self.print_help
        }.setdefault(commands[0] if len(commands) > 0 else 'help', self.print_help)()

    def print_help(self):
        self.tell("Usage: pyrit [options] command " \
            "\n\nRecognized options:" \
            "\n  -e    : ESSID for the command" \
            "\n  -f    : filename for the command ('-' is stdin/stdout)" \
            "\n\nRecognized commands:" \
            "\n  batch            : Batchprocess" \
            "\n  benchmark        : Determine performance of cores" \
            "\n  create_essid     : Create a new ESSID" \
            "\n  eval             : Count the passwords available and matching results" \
            "\n  export_cowpatty  : Export into a new cowpatty file" \
            "\n  export_hashdb    : Export into an existing airolib database" \
            "\n  import_passwords : Import passwords into the Password-blobspace" \
            "\n  list_cores       : List available cores" \
            "\n  list_essids      : List all ESSIDs in the ESSID-blobspace" \
            "\n  passthrough      : Compute PMKs on the fly and write to stdout" \
            "\n")

    def create_essid(self):
        essid = self.options.essid
        if essid is None:
            self.tell("One must specify a ESSID using the -e option. See 'help'", stream=sys.stderr)
        elif essid in self.essidstore:
            self.tell("ESSID already created", stream=sys.stderr)
        else:
            self.essidstore.create_essid(essid)
            self.tell("Created ESSID '%s'" % essid)

    def list_cores(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        self.tell("The following cores seem available...")
        for i, corename in enumerate(cp.availableCores()):
            self.tell("#%i:  '%s'" % (i+1, corename))

    def list_essids(self):
        self.tell("Listing ESSIDs...")
        for i, essid in enumerate(self.essidstore):
            self.tell("#%i:  '%s'" % (i, essid))
            
    def import_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
        else:
            self.tell("Importing from ", end=None)
            if self.options.file == "-":
                self.tell("stdin.")
                f = sys.stdin
            else:
                self.tell("'%s'" % self.options.file)
                f = open(self.options.file, "r")
            for i, line in enumerate(f):
                self.passwdstore.store_password(line)
                if i % 100000 == 0:
                    self.tell("\r%i lines read." % i, end=None, flush=True)
            f.close()
            self.tell("\r%i lines read. Flushing buffers..." % i)
            self.passwdstore.flush_buffer()
            self.tell("All done.")

    def eval_results(self):
        if self.options.essid is None:
            essid_objects = [self.essidstore[essid] for essid in self.essidstore]
        else:
            essid_objects = [self.essidstore[self.options.essid]]
        essid_results = {}
        pwcount = 0
        for pwfile in self.passwdstore:
            pwcount += len(pwfile)
            self.tell("Passwords:\t%i available\r" % pwcount, end=None, sep=None)
            pws = set(pwfile)
            for essid_obj in essid_objects:
                try:
                    essid_results[essid_obj] += len(pws.intersection(essid_obj[pwfile].results))
                except KeyError:
                    essid_results[essid_obj] = len(pws.intersection(essid_obj[pwfile].results))
        self.tell("\n")
        for essid, rescount in essid_results.iteritems():
            self.tell("ESSID '%s':\t%i done (%.2f%%)" % (essid, rescount, (rescount * 100.0 / pwcount) if pwcount > 0 else 0.0))
        self.tell("")

    def export_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.file == "-":
            for pwfile in self.passwdstore:
                sys.stdout.write("\n".join(pwfile))
                sys.stdout.write("\n")
            sys.stdout.flush()
        else:
            f = open(self.options.file, "wb")
            self.tell("Exporting to '%s'..." % self.options.file)
            lines = 0
            for pwfile in self.passwdstore:
                f.write("\n".join(pwfile))
                f.write("\n")
                lines += len(pwfile)
                self.tell("%i lines written\r" % lines, end=None, sep=None)
            f.close()
            self.tell("\nAll done")
    
    def _genCowpHeader(self, essid):
        return "APWC\00\00\00" + chr(len(essid)) + essid + '\00'*(32-len(essid))

    def _genCowpEntries(self, res):
        return "".join(map("".join, [(chr(len(passwd) + 32 + 1), passwd, pmk) for passwd, pmk in res]))
    
    def _genCowpatty(self, essid_obj):
        yield (0, self._genCowpHeader(essid_obj.essid))
        for key, result in essid_obj:
            yield (len(result), self._genCowpEntries(result.iteritems()))
    
    def export_cowpatty(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.essid is None:
            self.tell("The cowpatty-format only supports one ESSID per file. Please specify one using the -e option.", stream=sys.stderr)
            return
        if self.options.file == "-":
            awriter = AsyncFileWriter(sys.stdout)
            try:
                for l, buf in self._genCowpatty(self.essidstore[self.options.essid]):
                    awriter.write(buf)
                awriter.close()
            except IOError:
                self.tell("IOError while exporting to stdout ignored...", stream=sys.stderr)
        else:
            f = open(self.options.file, "wb")
            self.tell("Exporting to '%s'..." % self.options.file)
            lines = 0
            for l, buf in self._genCowpatty(self.essidstore[self.options.essid]):
                f.write(buf)
                lines += l
                self.tell("\r%i entries written..." % lines, end=None, sep=None)
            self.tell("\r%i entries written. All done." % lines)
            f.close()

    def passthrough(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        if self.options.essid is None:
            self.tell("Specifiy a ESSID using the -e option. See 'help'", stream=sys.stderr)
            return
        if self.options.file is None:
            self.tell("Specify a filename using the -f option to read passwords from. See 'help'", stream=sys.stderr)
            return
        if self.options.file == "-":
            f = sys.stdin
        else:
            f = open(self.options.file, "r")
        try:
            sys.stdout.write(self._genCowpHeader(self.options.essid))
            workunits = []
            pwbuffer = set()
            while True:
                l = f.readline()
                if l:
                    pw = l.strip()[:63]
                    if len(pw) >= 8:
                        pwbuffer.add(pw)
                if len(pwbuffer) > 20000 or (not l and len(pwbuffer) > 0):
                    workunits.append(list(pwbuffer))
                    cp.enqueue(self.options.essid, workunits[-1], 10)
                    pwbuffer = set()
                r = cp.dequeue(block=False)
                if r is not None:
                    sys.stdout.write(self._genCowpEntries(itertools.izip(workunits.pop(0), r)))
                if not l:
                    break
            for r in cp:
                sys.stdout.write(self._genCowpEntries(itertools.izip(workunits.pop(0), r)))
        except IOError:
            self.tell("IOError while writing to stdout ignored...", stream=sys.stderr)
        finally:
            f.close()

    def export_hashdb(self):
        if self.options.file is None:
            self.tell("You must specify the database filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.essid is None:
            essids = self.essidstore
        else:
            essids = [self.options.essid]

        con = sqlite3.connect(self.options.file)
        cur = con.cursor()
        cur.execute('SELECT * FROM sqlite_master')
        tbls = [x[1] for x in cur.fetchall() if x[0] == u'table']
        if u'pmk' not in tbls or u'essid' not in tbls or u'passwd' not in tbls:
            self.tell("The database '%s' seems to be uninitialized. "  % self.options.file +
                      "Trying to create default table-layout...", end=None)
            try:
                cur.execute("CREATE TABLE essid (essid_id INTEGER PRIMARY KEY AUTOINCREMENT, essid TEXT, prio INTEGER DEFAULT 64)")
                cur.execute("CREATE TABLE passwd (passwd_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd TEXT)")
                cur.execute("CREATE TABLE pmk (pmk_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd_id INT, essid_id INT, pmk BLOB)")
                cur.execute("CREATE TABLE workbench (wb_id INTEGER PRIMARY KEY AUTOINCREMENT, essid_id INT, passwd_id INT, lockid INTEGER DEFAULT 0)")
                cur.execute("CREATE INDEX lock_lockid ON workbench (lockid);")
                cur.execute("CREATE UNIQUE INDEX essid_u ON essid (essid)")
                cur.execute("CREATE UNIQUE INDEX passwd_u ON passwd (passwd)")
                cur.execute("CREATE UNIQUE INDEX ep_u ON pmk (essid_id, passwd_id)")
                cur.execute("CREATE UNIQUE INDEX wb_u ON workbench (essid_id, passwd_id)")
                cur.execute("CREATE TRIGGER delete_essid DELETE ON essid BEGIN DELETE FROM pmk WHERE pmk.essid_id = OLD.essid_id; DELETE FROM workbench WHERE workbench.essid_id = OLD.essid_id; END;")
                cur.execute("CREATE TRIGGER delete_passwd DELETE ON passwd BEGIN DELETE FROM pmk WHERE pmk.passwd_id = OLD.passwd_id; DELETE FROM workbench WHERE workbench.passwd_id = OLD.passwd_id; END;")
                self.tell("Tables created...")
            except:
                con.rollback()
                cur.close()
                con.close()
                self.tell("Failed to initialize the database:", stream=sys.stderr)
                raise

        for essid in essids:
            self.tell("Exporting ESSID '%s'" % essid)
            essid_obj = self.essidstore[essid]
            try:
                cur.execute('INSERT OR IGNORE INTO essid (essid) VALUES (?)', (essid,))
                essid_id = cur.execute('SELECT essid_id FROM essid WHERE essid = ?', (essid,)).fetchone()[0]
                cur.execute('CREATE TEMPORARY TABLE import (passwd_id int key, passwd text key, pmk blob)')
                for key, result in essid_obj:
                    cur.executemany('INSERT INTO import (passwd, pmk) VALUES (?,?)', ((pw, buffer(res)) for pw, res in result.items()))
                cur.execute('UPDATE import SET passwd_id = (SELECT passwd.passwd_id FROM passwd WHERE passwd.passwd = import.passwd)')
                cur.execute('INSERT INTO passwd (passwd) SELECT passwd FROM import WHERE import.passwd_id IS NULL')
                cur.execute('UPDATE import SET passwd_id = (SELECT passwd.passwd_id FROM passwd WHERE passwd.passwd = import.passwd) WHERE passwd_id IS NULL')
                cur.execute('INSERT OR IGNORE INTO pmk (essid_id,passwd_id,pmk) SELECT ?, passwd_id, pmk FROM import', (essid_id,))
                cur.execute('DROP TABLE import')
            except:
                con.rollback()
                cur.close()
                con.close()
                self.tell("There was an error while exporting. The database has not been modified...", stream=sys.stderr)
                raise
        con.commit()
        cur.close()
        con.close()

    def batchprocess(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        def _writeCowpatty(resFile):
            if self.options.file == '-':
                try:
                    sys.stdout.write(self._genCowpEntries(resFile.results.iteritems()))
                except IOError:
                    self.tell("IOError while writing to stdout. Batchprocessing continues silently...", stream=sys.stderr)
                    self.options.file = ''                        
        
        if self.options.file == "-" and self.options.essid is None:
            self.tell("Results will be written to stdout while batchprocessing. This requires to specify a ESSID.", stream=sys.stderr) 
            return
            
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = self.essidstore

        pwfile = None
        try: 
            totalResCount = 0
            startTime = time.time()
            workunits = []
            for essid in essids:
                essid_object = self.essidstore[essid]
                self.tell("Working on ESSID '%s'" % essid_object.essid)
                if self.options.file == "-":
                    sys.stdout.write(self._genCowpHeader(essid_object.essid))

                for pwfile in self.passwdstore:
                    resFile = essid_object[pwfile]
                    unsolvedPasswds = list(set(pwfile).difference(set(resFile.results.keys())))
                    if len(unsolvedPasswds) > 0:
                        workunits.append((resFile, unsolvedPasswds))
                        cp.enqueue(essid_object.essid, unsolvedPasswds, True)
                    else:
                        _writeCowpatty(resFile)
                    newResults = cp.dequeue(block=False)
                    if newResults is not None:
                        newResFile, solvedPasswds = workunits.pop(0)
                        newResFile.results.update(itertools.izip(solvedPasswds, newResults))
                        newResFile.savefile()
                        _writeCowpatty(newResFile)
                        totalResCount += len(newResults)
                    tdiff = time.time() - startTime
                    self.tell("Computed %i PMKs in %.2f seconds; %.1f PMKs per second.\r" % (totalResCount, tdiff, totalResCount / tdiff), end=None, sep=None)
                self.tell("")
            self.tell("Stopped reading workunits...")
            for newResults in cp:
                newResFile, solvedPasswds = workunits.pop(0)
                newResFile.results.update(itertools.izip(solvedPasswds, newResults))
                newResFile.savefile()
                _writeCowpatty(newResFile)
                totalResCount += len(newResults)

        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        except:
            self.tell("Unhandled exception while batchprocessing '%s'" % pwfile, stream=sys.stderr)
            raise
        finally:
            try:
                if totalResCount > 0:   
                    self.tell("\nAll done. %.2f PMKs/s total." % (totalResCount / tdiff))
                    tdiff = time.time() - startTime
                    for core in cp.cores:
                        resCount, compTime = core.getStats()
                        self.tell("%s: %.2f PMKs/s, %.2f%% occupancy" % (core.name, (resCount / compTime) if compTime > 0 else 0 , compTime * 100.0 / tdiff))
            except:
                raise
        self.tell("Batchprocessing done.")

    def benchmark(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        print "Running benchmark for at least 60 seconds...\n"
        t = time.time()
        while time.time() - t < 60:
            cp.enqueue('foo', ['barbarbar']*3500, block=True)
            while True:
                r = cp.dequeue(block=False)
                if r is None:
                    break
        for r in cp:
            pass
        total = 0
        tdiff = time.time() - t
        for core in cp.cores:
            resCount, compTime = core.getStats()
            print "%s: %.2f PMKs/s, %.2f%% occupancy" % (core.name, resCount / compTime , compTime * 100.0 / tdiff)
            total += resCount / compTime
        print "\nBenchmark done. %.2f PMKs/s total." % total


class PyrFile(object):
    def __init__(self, essid, filename):
        self.results = {}
        self.essid = essid
        self.filename = filename
        self.key = None 
        if os.path.exists(filename):
            self.key = filename.split(os.path.sep)[-1][:-4]
            f = open(filename, "rb")
            buf = f.read()
            f.close()
            if len(buf) > 0:
                md = hashlib.md5()
                preheadfmt = "<4sH"
                preheadsize = struct.calcsize(preheadfmt)
                magic, essidlen = struct.unpack(preheadfmt, buf[:preheadsize])
                assert magic == "PYR2"
                headfmt = "<%ssi%ss" % (essidlen, md.digest_size)
                headsize = struct.calcsize(headfmt)
                essid, numElems, digest = struct.unpack(headfmt, buf[preheadsize:preheadsize+headsize])
                assert essid == self.essid
                pmkoffset = preheadsize + headsize
                pwoffset = pmkoffset + numElems * 32
                md.update(essid)
                md.update(buf[pmkoffset:])
                if md.digest() != digest:
                    raise Exception, "Digest check failed on PyrFile '%s'." % filename
                self.results = dict(itertools.izip(
                                    zlib.decompress(buf[pwoffset:]).split("\n"),
                                    [buf[pmkoffset + i*32:pmkoffset + i*32 + 32] for i in xrange(numElems)]
                                    ))
                assert len(self.results) == numElems

    def savefile(self):
        pws, pmks = itertools.izip(*self.results.items())
        pmkbuffer = "".join(pmks)
        pwbuffer = zlib.compress("\n".join(pws), 1)
        md = hashlib.md5()
        md.update(self.essid)
        md.update(pmkbuffer)
        md.update(pwbuffer)
        f = open(self.filename, "wb")
        f.write(struct.pack("<4sH%ssi%ss" % (len(self.essid), md.digest_size), "PYR2", len(self.essid), self.essid, len(pws), md.digest()))
        f.write(pmkbuffer)
        f.write(pwbuffer)
        f.close()


class ESSID(object):
    def __init__(self, path):
        self.path = path
        try:
            self.f = open(os.path.join(path, "essid"), "rb")
        except IOError:
            raise IOError, "ESSID not found or not accessible."
        self.essid = self.f.read()

    def __len__(self):
        return len([x[:-4] for x in os.listdir(self.path) if x[-4:] == '.pyr'])

    def __repr__(self):
        return self.essid

    def __iter__(self):
        if self.f is None:
            raise Exception, "ESSID not locked."
        for key, results in ((k, dict(self._getPyrFile(k).results)) for k in (x[:-4] for x in os.listdir(self.path) if x[-4:] == '.pyr')):
            yield (key, results)

    def __getitem__(self, key):
        return self._getPyrFile(key)
        
    def __setitem__(self, key, value):
        assert isinstance(value, dict)
        pyrfile = self._getPyrFile(key)
        pyrfile.results = value
        self.resultwriter.savefile(pyrfile)

    def close(self):
        if self.f is not None:
            self.f.close()
        self.f = None
        self.path = None
        self.essid = None
     
    def _getPyrFile(self, key):
        if self.f is None:
            raise Exception, "ESSID not locked."
        if isinstance(key, str):
            fname = key
        elif isinstance(key, PasswordFile):
            fname = key.key
        else:
            raise AssertionError, "Don't know how to get results based on parameter of class '%s'." % key.__class__
        return PyrFile(self.essid, os.path.join(self.path, fname+".pyr"))


class EssidStore(object):
    def __init__(self,basepath):
        self.essidpath = basepath
        self._makedir(self.essidpath)

    def _makedir(self, pathname):
        try:
            os.makedirs(pathname)
        except OSError, (errno, sterrno):
            if errno == 17:
                pass
            else:
                raise

    def _getessidroot(self, essid):
        return os.path.join(self.essidpath, hashlib.md5(essid).hexdigest()[:8])

    def __getitem__(self, essid):
        return ESSID(self._getessidroot(essid))

    def __len__(self):
        return len([x for x in self])

    def __iter__(self):
        for essid_hash in os.listdir(self.essidpath):
            f = open(os.path.join(self.essidpath, essid_hash,'essid'), "rb")
            essid = f.read()
            f.close()
            if essid_hash == hashlib.md5(essid).hexdigest()[:8]:
                yield essid
            else:
                print >>sys.stderr, "ESSID %s seems to be corrupted." % essid_hash

    def create_essid(self,essid):
        if len(essid) < 3 or len(essid) > 32:
            raise Exception, "ESSID invalid."
        essid_root = self._getessidroot(essid)
        self._makedir(essid_root)
        f = open(os.path.join(essid_root,'essid'), "wb")
        f.write(essid)
        f.close()


class PasswordFile(object):
    def __init__(self, filepath, filename=None):
        self.bucket = set()
        self.filepath = filepath
        self.key = None
        if filename:
            f = open(os.path.join(filepath, filename), "rb")
            buf = f.read()
            f.close()
            if len(buf) > 0:
                if buf[:4] != "PAW2":
                    raise Exception, "'%s' is not a PasswordFile." % filename
                md = hashlib.md5()
                md.update(buf[4+md.digest_size:])
                if md.digest() != buf[4:4+md.digest_size]:
                    raise Exception, "Digest check failed for %s" % filename
                self.key = md.hexdigest()
                if filename[-3-len(self.key):-3] != self.key:
                    raise Exception, "File '%s' doesn't match the key '%s'." % (filename, md.hexdigest())
                self.bucket = frozenset(zlib.decompress(buf[4+md.digest_size:]).split("\n"))

    def __repr__(self):
        return "Passwordfile '%s' in '%s'" % (self.key, self.filepath)

    def __iter__(self):
        return self.bucket.__iter__()
            
    def __len__(self):
        return len(self.bucket)

    def savefile(self):
        md = hashlib.md5()
        b = zlib.compress("\n".join(sorted(self.bucket)), 1)
        md.update(b)
        if self.key and self.key != md.hexdigest():
            raise Exception, "PasswordFile unstable."
        if not os.path.exists(self.filepath):
            os.makedirs(self.filepath)
        f = open(os.path.join(self.filepath, md.hexdigest() + ".pw"), "wb")
        f.write("PAW2")
        f.write(md.digest())
        f.write(b)
        f.close()


class PasswordStore(object):
    h1_list = ["%02.2X" % i for i in xrange(256)]
    def __init__(self, basepath):
        self.passwdpath = basepath
        self._makedir(self.passwdpath)
        self.pwbuffer = {}

    def _makedir(self,pathname):
        try:
            os.makedirs(pathname)
        except OSError, (errno, sterrno):
            if errno == 17:
                pass

    def _getfiles(self, filt=None):
        pwfiles = {}
        for pw_h1 in [x for x in os.listdir(self.passwdpath) if x == filt or filt is None]:
            for pw in [x for x in os.listdir(os.path.join(self.passwdpath, pw_h1)) if x[-3:] == '.pw']:
                pwfiles[pw[:len(pw)-3]] = (os.path.join(self.passwdpath, pw_h1), pw)
        return pwfiles

    def __iter__(self):
        for pwpath, pwfile in self._getfiles().values():
            yield PasswordFile(pwpath, pwfile)

    def __getitem__(self, key):
        return PasswordFile(*self._getfiles()[key])

    def _flush_bucket(self, pw_h1, bucket):
        if len(bucket) == 0:
            return
        for pwpath, pwfile in self._getfiles(pw_h1).values():
            bucket -= PasswordFile(pwpath, pwfile).bucket
        if len(bucket) == 0:
            return
        f = PasswordFile(filepath = os.path.join(self.passwdpath, pw_h1))
        f.bucket = bucket
        f.savefile()

    def flush_buffer(self):
        for pw_h1, pwlist in [(pw_h1, list(pwbucket)) for pw_h1, pwbucket in self.pwbuffer.iteritems() if len(pwbucket) > 0]:
            for pwslice in (set(pwlist[x:x+20000]) for x in xrange(0, len(pwlist), 20000)):
                self._flush_bucket(pw_h1, pwslice)
            self.pwbuffer[pw_h1] = set()

    def store_password(self, passwd):
        passwd = passwd.strip()
        if len(passwd) < 8 or len(passwd) > 63:
            return
        pw_h1 = PasswordStore.h1_list[hash(passwd) & 0xFF]
        pw_bucket = self.pwbuffer.setdefault(pw_h1, set())
        pw_bucket.add(passwd)
        if len(pw_bucket) >= 20000:
            self._flush_bucket(pw_h1, pw_bucket)
            self.pwbuffer[pw_h1] = set()


if __name__ == "__main__":
    try:
        import psyco
    except ImportError:
        pass
    else:
        psyco.full()
    p = Pyrit_CLI()
    p.init()

