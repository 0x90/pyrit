#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
#    Copyright 2008, 2009, Lukas Lueg, knabberknusperhaus@yahoo.de
#
#    This file is part of Pyrit.
#
#    Pyrit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Pyrit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Pyrit.  If not, see <http://www.gnu.org/licenses/>.

import BaseHTTPServer
import getopt
import hashlib
import httplib
import itertools
import os
import random
import re
import struct
import sys
import sqlite3
import SocketServer
import cStringIO
import threading
import time
import uuid
import urlparse
import zlib

PMK_TESTVECTORS = {
    'foo': {
        'soZcEvntHVrGRDIxNaBCyUL': (247,210,173,42,68,187,144,253,145,93,126,250,16,188,100,55,89,153,135,155,198,86,124,33,45,16,9,54,113,194,159,211),
        'EVuYtpQCAZzBXyWNRGTI': (5,48,168,39,10,98,151,201,8,80,23,138,19,24,24,50,66,214,189,180,159,97,194,27,212,124,114,100,253,62,50,170),
        'XNuwoiGMnjlkxBHfhyRgZrJItFDqQVESm': (248,208,207,115,247,35,170,203,214,228,228,21,40,214,165,0,98,194,136,62,110,253,69,205,67,215,119,109,72,226,255,199),
        'bdzPWNTaIol': (228,236,73,0,189,244,21,141,84,247,3,144,2,164,99,205,37,72,218,202,182,246,227,84,24,58,147,114,206,221,40,127),
        'nwUaVYhRbvsH': (137,21,14,210,213,68,210,123,35,143,108,57,196,47,62,161,150,35,165,197,154,61,76,14,212,88,125,234,51,38,159,208),
        'gfeuvPBbaDrQHldZzRtXykjFWwAhS': (88,127,99,35,137,177,147,161,244,32,197,233,178,1,96,247,5,109,163,250,35,222,188,143,155,70,106,1,253,79,109,135),
        'QcbpRkAJerVqHz': (158,124,37,190,197,150,225,165,3,34,104,147,107,253,233,127,33,239,75,11,169,187,127,171,187,165,166,187,95,107,137,212),
        'EbYJsCNiwXDmHtgkFVacuOv': (136,5,34,189,145,60,145,54,179,198,195,223,34,180,144,3,116,102,39,134,68,82,210,185,190,199,36,25,136,152,0,111),
        'GpIMrFZwLcqyt': (28,144,175,10,200,46,253,227,219,35,98,208,220,11,101,95,62,244,80,221,111,49,206,255,174,100,240,240,33,229,172,207),
        'tKxgswlaOMLeZVScGDW': (237,62,117,60,38,107,65,166,113,174,196,221,128,227,69,89,23,77,119,234,41,176,145,105,92,40,157,151,229,50,81,65)
        },
    'bar': {
        'zLwSfveNskZoR': (38,93,196,77,112,65,163,197,249,158,180,107,231,140,188,60,254,77,12,210,77,185,233,59,79,212,222,181,44,19,127,220),
        'lxsvOCeZXop': (91,39,98,36,82,2,162,106,12,244,4,113,155,120,131,133,11,209,12,12,240,213,203,156,129,148,28,64,31,61,162,13),
        'tfHrgLLOA': (110,72,123,80,222,233,150,54,40,99,205,155,177,157,174,172,87,11,247,164,87,85,136,165,21,107,93,212,71,133,145,211),
        'vBgsaSJrlqajUlQJM': (113,110,180,150,204,221,61,202,238,142,147,118,177,196,65,79,102,47,179,80,175,95,251,35,227,220,47,121,50,125,55,16),
        'daDIHwIMKSUaKWXS': (33,87,211,99,26,70,123,19,254,229,148,97,252,182,3,44,228,125,85,141,247,223,166,133,246,37,204,145,100,218,66,70),
        'agHOeAjOpK': (226,163,62,215,250,63,6,32,130,34,117,116,189,178,245,172,74,26,138,10,106,119,15,214,210,114,51,94,254,57,81,200),
        'vRfEagJIzSohxsakj': (61,71,159,35,233,27,138,30,228,121,38,201,57,83,192,211,248,207,149,12,147,70,190,216,52,14,165,190,226,180,62,210),
        'PuDomzkiwsejblaXs': (227,164,137,231,16,31,222,169,134,1,238,190,55,126,255,88,178,118,148,119,244,130,183,219,124,249,194,96,94,159,163,185),
        'RErvpNrOsW': (24,145,197,137,14,154,1,36,73,148,9,192,138,157,164,81,47,184,41,75,225,34,71,153,59,253,127,179,242,193,246,177),
        'ipptbpKkCCep': (81,34,253,39,124,19,234,163,32,10,104,88,249,29,40,142,24,173,1,68,187,212,21,189,74,88,83,228,7,100,23,244)
        }
    }

class AsyncFileWriter(threading.Thread):
    def __init__(self, filehndl, maxsize=10*1024**2):
        threading.Thread.__init__(self)
        self.shallstop = False
        self.filehndl = filehndl
        self.maxsize = maxsize
        self.excp = None
        self.buf = cStringIO.StringIO()
        self.cv = threading.Condition()
        self.start()
        
    def close(self):
        self.cv.acquire()
        try:
            self.shallstop = True
            self.cv.notifyAll()
            while self.isAlive():
                self.cv.wait()
            self._raise
        finally:
            self.cv.release()

    def write(self, data):
        self.cv.acquire()
        try:
            self._raise()
            while self.buf.tell() > self.maxsize and not self.shallstop:
                self.cv.wait()
                if self.shallstop:
                    raise Exception, "Writer has already been closed."
            self.buf.write(data)
            self.cv.notifyAll()
        finally:
            self.cv.release()

    def _raise(self):
        if self.excp:
            e = self.excp
            self.excp = None
            self.shallstop = True
            self.cv.notifyAll()
            raise type(e)(str(e))

    def run(self):
        try:
            while self.buf.tell() > 0 or not self.shallstop:
                self.cv.acquire()
                try:
                    while self.buf.tell() == 0 and not self.shallstop:
                        self.cv.wait()
                    data = self.buf.getvalue()
                    self.buf = cStringIO.StringIO()
                    self.cv.notifyAll()
                finally:
                    self.cv.release()
                self.filehndl.write(data)
        except Exception, e:
            self.shallstop = True
            self.excp = e
        finally:
            self.cv.acquire()
            self.cv.notifyAll()
            self.cv.release()


class Pyrit_CLI(object):
    class options(object):
        def __init__(self):
            self.essidstore_path = os.path.expanduser(os.path.join('~','.pyrit','blobspace','essid'))
            self.passwdstore_path = os.path.expanduser(os.path.join('~','.pyrit','blobspace','password'))
            self.essid = None
            self.file = None
            self.verbose = True
    
    def __init__(self):
        # I *hate* the lookup syntax in the code further below if options is a dict
        self.options = self.options()
        
    def tell(self, text, sep=' ', end='\n', stream=sys.stdout, flush=False):
        if self.options.verbose or stream != sys.stdout:
            stream.write(text)
            if end is not None:
                stream.write(end)
            else:
                if sep is not None:
                    stream.write(sep)
            if flush or end is None:
                stream.flush()
        
    def init(self):
        options, commands = getopt.getopt(sys.argv[1:], "u:v:c:e:f:")
        for option, value in dict(options).items():
            if option == '-e':
                self.options.essid = value
            elif option == '-f':
                self.options.file = value
            else:
                self.tell("Option '%s' not known. Ignoring..." % option)
        if self.options.file == "-" or 'passthrough' in commands:
            self.options.verbose = False

        self.essidstore = EssidStore(self.options.essidstore_path)
        self.passwdstore = PasswordStore(self.options.passwdstore_path)

        self.tell("Pyrit 0.2.3-dev (C) 2008, 2009 Lukas Lueg http://pyrit.googlecode.com" \
                "\nThis code is distributed under the GNU General Public License v3\n")
        if len(self.essidstore) == 0 and len(commands) > 0 and commands[0] != "create_essid":
            self.tell("The ESSID-blobspace seems to be empty; you should create an ESSID...\n", stream=sys.stderr)

        {'export_cowpatty': self.export_cowpatty,
        'export_hashdb': self.export_hashdb,
        'export_passwords': self.export_passwords,
        'import_passwords': self.import_passwords,
        'list_cores': self.list_cores,
        'list_essids': self.list_essids,
        'create_essid': self.create_essid,
        'delete_essid': self.delete_essid,
        'eval': self.eval_results,
        'batch': self.batchprocess,
        'batchprocess': self.batchprocess,
        'passthrough': self.passthrough,
        'benchmark': self.benchmark,
        'serve': self.serve,
        'selftest': self.selftest,
        'verify': self.verify,
        'help': self.print_help
        }.setdefault(commands[0] if len(commands) > 0 else 'help', self.print_help)()

    def print_help(self):
        self.tell("Psyco-acceleration " + ("enabled.\n" if "psyco" in sys.modules else "not used.\n"))
        self.tell("Usage: pyrit [options] command " \
            "\n\nRecognized options:" \
            "\n  -e    : ESSID for the command" \
            "\n  -f    : filename for the command ('-' is stdin/stdout)" \
            "\n\nRecognized commands:" \
            "\n  batch            : Batchprocess" \
            "\n  benchmark        : Determine performance of available cores" \
            "\n  create_essid     : Create a new ESSID" \
            "\n  delete_essid     : Delete a ESSID and corresponding results" \
            "\n  eval             : Count the available passwords and matching results" \
            "\n  export_cowpatty  : Export into a new cowpatty file" \
            "\n  export_hashdb    : Export into an airolib database" \
            "\n  import_passwords : Import passwords" \
            "\n  list_cores       : List available cores" \
            "\n  list_essids      : List all ESSIDs but don't count matching results" \
            "\n  passthrough      : Compute PMKs on the fly and write to stdout" \
            "\n  serve            : Serve requests from clients on the network" \
            "\n  selftest         : Test all cores for computing correct results" \
            "\n  verify           : Verify 10% of the results through recomputation" \
            "\n")

    def create_essid(self):
        if self.options.essid is None:
            self.tell("You must specify a ESSID using the -e option. See 'help'.", stream=sys.stderr)
        elif self.options.essid in self.essidstore:
            self.tell("ESSID already created", stream=sys.stderr)
        else:
            self.essidstore.create_essid(self.options.essid)
            self.tell("Created ESSID '%s'" % self.options.essid)

    def delete_essid(self):
        if self.options.essid is None:
            self.tell("You must specify a ESSID using the -e option. See 'help'.", stream=sys.stderr)
        elif self.options.essid not in self.essidstore:
            self.tell("ESSID not found...", stream=sys.stderr)
        else:
            self.tell("All results for ESSID '%s' will be deleted! Continue? [y/N]" % self.options.essid, end=None)
            if sys.stdin.readline().strip() == 'y':
                self.tell("deleting...")
                self.essidstore.delete_essid(self.options.essid)
                self.tell("Deleted ESSID '%s'." % self.options.essid)
            else:
                self.tell("aborted.")

    def list_cores(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        self.tell("The following cores seem available...")
        for i, corename in enumerate(cp.availableCores()):
            self.tell("#%i:  '%s'" % (i+1, corename))

    def list_essids(self):
        self.tell("Listing ESSIDs...")
        for i, essid in enumerate(self.essidstore):
            self.tell("#%i:  '%s'" % (i, essid))
            
    def import_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
        else:
            self.tell("Importing from ", end=None)
            if self.options.file == "-":
                self.tell("stdin.")
                f = sys.stdin
            else:
                self.tell("'%s'" % self.options.file)
                f = open(self.options.file, "r")
            for i, line in enumerate(f):
                self.passwdstore.store_password(line)
                if i % 100000 == 0:
                    self.tell("\r%i lines read." % i, end=None, flush=True)
            f.close()
            self.tell("\r%i lines read. Flushing buffers..." % (i + 1))
            self.passwdstore.flush_buffer()
            self.tell("All done.")

    def eval_results(self):
        if self.options.essid is None:
            essid_objects = [self.essidstore[essid] for essid in self.essidstore]
        else:
            essid_objects = [self.essidstore[self.options.essid]]
        essid_results = {}
        pwcount = 0
        for pwfile in self.passwdstore:
            pwcount += len(pwfile)
            self.tell("Passwords available:\t%i\r" % pwcount, end=None, sep=None)
            for essid_obj in essid_objects:
                try:
                    essid_results[essid_obj] += len(essid_obj[pwfile])
                except KeyError:
                    essid_results[essid_obj] = len(essid_obj[pwfile])
        self.tell("Passwords available:\t%i\n" % pwcount)
        for essid, rescount in sorted(essid_results.items()):
            self.tell("ESSID '%s':\t%i (%.2f%%)" % (essid, rescount, (rescount * 100.0 / pwcount) if pwcount > 0 else 0.0))
        self.tell("")

    def export_passwords(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.file == "-":
            for pwfile in self.passwdstore:
                sys.stdout.write("\n".join(pwfile))
                sys.stdout.write("\n")
            sys.stdout.flush()
        else:
            f = open(self.options.file, "wb")
            self.tell("Exporting to '%s'..." % self.options.file)
            lines = 0
            for pwfile in self.passwdstore:
                f.write("\n".join(pwfile))
                f.write("\n")
                lines += len(pwfile)
                self.tell("%i lines written\r" % lines, end=None, sep=None)
            f.close()
            self.tell("\nAll done")
    
    def _genCowpHeader(self, essid):
        return "APWC\00\00\00" + chr(len(essid)) + essid + '\00'*(32-len(essid))

    def _genCowpEntries(self, res):
        return "".join(map("".join, [(chr(len(passwd) + 32 + 1), passwd, pmk) for passwd, pmk in res]))
    
    def _genCowpatty(self, essid_obj):
        yield (0, self._genCowpHeader(essid_obj.essid))
        for key, result in essid_obj:
            yield (len(result), self._genCowpEntries(result.iteritems()))
    
    def export_cowpatty(self):
        if self.options.file is None:
            self.tell("One must specify a filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.essid is None:
            essid = self.options.file.split('.')[0]
            if essid in self.essidstore:
                self.options.essid = essid
            else:
                self.tell("The cowpatty-format only supports one ESSID per file. Please specify one using the -e option.", stream=sys.stderr)
                return
        if self.options.file == "-":
            f = sys.stdout
        else:
            f = open(self.options.file, "wb")
        lines = 0
        self.tell("Exporting to '%s'..." % self.options.file)
        awriter = AsyncFileWriter(f)
        try:
            for l, buf in self._genCowpatty(self.essidstore[self.options.essid]):
                awriter.write(buf)
                lines += l
                self.tell("\r%i entries written..." % lines, end=None, sep=None)
            self.tell("\r%i entries written. All done." % lines)
        except IOError:
            self.tell("IOError while exporting to stdout ignored...", stream=sys.stderr)
        finally:
            awriter.close()
            f.close()

    def passthrough(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        if self.options.essid is None:
            self.tell("Specifiy a ESSID using the -e option. See 'help'", stream=sys.stderr)
            return
        if self.options.file is None:
            self.tell("Specify a filename using the -f option to read passwords from. See 'help'", stream=sys.stderr)
            return
        if self.options.file == "-":
            f = sys.stdin
        else:
            f = open(self.options.file, "r")
        awriter = AsyncFileWriter(sys.stdout)       
        try:
            awriter.write(self._genCowpHeader(self.options.essid))
            workunits = []
            pwbuffer = set()
            while True:
                l = f.readline()
                if l:
                    pw = l.strip()[:63]
                    if len(pw) >= 8:
                        pwbuffer.add(pw)
                if len(pwbuffer) > 20000 or (not l and len(pwbuffer) > 0):
                    workunits.append(list(pwbuffer))
                    cp.enqueue(self.options.essid, workunits[-1], True)
                    pwbuffer = set()
                r = cp.dequeue(block=False)
                if r is not None:
                    awriter.write(self._genCowpEntries(itertools.izip(workunits.pop(0), r)))
                if not l:
                    break
            for r in cp:
                awriter.write(self._genCowpEntries(itertools.izip(workunits.pop(0), r)))
        except IOError:
            self.tell("IOError while writing to stdout ignored...", stream=sys.stderr)
        finally:
            awriter.close()
            f.close()

    def export_hashdb(self):
        if self.options.file is None:
            self.tell("You must specify the database filename using the -f option. See 'help'", stream=sys.stderr)
            return
        if self.options.essid is None:
            essids = self.essidstore
        else:
            essids = [self.options.essid]

        con = sqlite3.connect(self.options.file)
        con.text_factory = str
        cur = con.cursor()
        cur.execute('SELECT * FROM sqlite_master')
        tbls = [x[1] for x in cur.fetchall() if x[0] == u'table']
        if u'pmk' not in tbls or u'essid' not in tbls or u'passwd' not in tbls:
            self.tell("The database '%s' seems to be uninitialized. "  % self.options.file +
                      "Trying to create default table-layout...", end=None)
            try:
                cur.execute("CREATE TABLE essid (essid_id INTEGER PRIMARY KEY AUTOINCREMENT, essid TEXT, prio INTEGER DEFAULT 64)")
                cur.execute("CREATE TABLE passwd (passwd_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd TEXT)")
                cur.execute("CREATE TABLE pmk (pmk_id INTEGER PRIMARY KEY AUTOINCREMENT, passwd_id INT, essid_id INT, pmk BLOB)")
                cur.execute("CREATE TABLE workbench (wb_id INTEGER PRIMARY KEY AUTOINCREMENT, essid_id INT, passwd_id INT, lockid INTEGER DEFAULT 0)")
                cur.execute("CREATE INDEX lock_lockid ON workbench (lockid);")
                cur.execute("CREATE UNIQUE INDEX essid_u ON essid (essid)")
                cur.execute("CREATE UNIQUE INDEX passwd_u ON passwd (passwd)")
                cur.execute("CREATE UNIQUE INDEX ep_u ON pmk (essid_id, passwd_id)")
                cur.execute("CREATE UNIQUE INDEX wb_u ON workbench (essid_id, passwd_id)")
                cur.execute("CREATE TRIGGER delete_essid DELETE ON essid BEGIN DELETE FROM pmk WHERE pmk.essid_id = OLD.essid_id; DELETE FROM workbench WHERE workbench.essid_id = OLD.essid_id; END;")
                cur.execute("CREATE TRIGGER delete_passwd DELETE ON passwd BEGIN DELETE FROM pmk WHERE pmk.passwd_id = OLD.passwd_id; DELETE FROM workbench WHERE workbench.passwd_id = OLD.passwd_id; END;")
                self.tell("Tables created...")
            except:
                con.rollback()
                cur.close()
                con.close()
                self.tell("Failed to initialize the database:", stream=sys.stderr)
                raise
        try:
            cur.execute("PRAGMA synchronous = 1")
            i = 0
            print "Writing passwords..."
            for pwfile in self.passwdstore:
                i += len(pwfile)
                cur.executemany('INSERT OR IGNORE INTO passwd (passwd) VALUES (?)', [(pw,) for pw in pwfile])
                self.tell("Wrote %i lines...\r" % i, end=None, sep=None)
            print "\nWriting ESSIDs and results..."
            for essid in essids:
                self.tell("Writing '%s'..." % essid)
                cur.execute('INSERT OR IGNORE INTO essid (essid) VALUES (?)', (essid,))
                essid_id = cur.execute('SELECT essid_id FROM essid WHERE essid = ?', (essid,)).fetchone()[0]
                i = 0
                for key, result in self.essidstore[essid]:
                    i += len(result)
                    cur.executemany('INSERT OR IGNORE INTO pmk (essid_id, passwd_id, pmk) SELECT ?, passwd_id, ? FROM passwd WHERE passwd = ?',
                                    ((essid_id, buffer(pmk), pw) for pw, pmk in result.iteritems()))
                    self.tell("Wrote %i lines...\r" % i, end=None, sep=None)
            print "\nAll done."
        except:
            con.rollback()
            self.tell("There was an error while exporting. The database has not been modified...", stream=sys.stderr)
            raise
        else:
            con.commit()
        finally:
            cur.close()
            con.close()

    def batchprocess(self):
        import cpyrit
        cp = cpyrit.CPyrit()

        def _writeCowpatty(out, resFile):
            if self.options.file == '-':
                try:
                    out.write(self._genCowpEntries(resFile.results.iteritems()))
                except IOError:
                    self.tell("IOError while writing to stdout. Batchprocessing continues silently...", stream=sys.stderr)
                    self.options.file = ''                        
        
        if self.options.file == "-" and self.options.essid is None:
            self.tell("Results will be written to stdout while batchprocessing. This requires to specify a ESSID.", stream=sys.stderr) 
            return
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = self.essidstore
        
        totalResCount = 0
        startTime = time.time()
        workunits = []
        awriter = AsyncFileWriter(sys.stdout) 
        try: 
            for essid in essids:
                essid_object = self.essidstore[essid]
                self.tell("Working on ESSID '%s'" % essid_object.essid)
                if self.options.file == "-":
                    awriter.write(self._genCowpHeader(essid_object.essid))

                for pwfile in self.passwdstore:
                    resFile = essid_object[pwfile]
                    if len(resFile) < len(pwfile):
                        pws = list(pwfile)
                        workunits.append((resFile, pws))
                        cp.enqueue(essid_object.essid, pws, True)
                    else:
                        _writeCowpatty(awriter, resFile)
                    newResults = cp.dequeue(block=False)
                    if newResults is not None:
                        newResFile, solvedPasswds = workunits.pop(0)
                        newResFile.results.update(itertools.izip(solvedPasswds, newResults))
                        newResFile.savefile()
                        totalResCount += len(newResults)
                        _writeCowpatty(awriter, newResFile)
                    tdiff = time.time() - startTime
                    self.tell("Computed %i PMKs in %i seconds; %i PMKs per second.\r" % (totalResCount, tdiff, totalResCount / tdiff), end=None, sep=None)
                self.tell("")
            self.tell("Stopped reading workunits...")
            for newResults in cp:
                newResFile, solvedPasswds = workunits.pop(0)
                newResFile.results.update(itertools.izip(solvedPasswds, newResults))
                newResFile.savefile()
                _writeCowpatty(awriter, newResFile)
                totalResCount += len(newResults)
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        except:
            self.tell("Unhandled exception while batchprocessing '%s'" % pwfile, stream=sys.stderr)
            raise
        finally:
            awriter.close()
            if totalResCount > 0:   
                tdiff = time.time() - startTime
                self.tell("\nAll done. %.2f PMKs/s total." % (totalResCount / tdiff))
                for core in cp.cores:
                    resCount, compTime = core.getStats()
                    self.tell("%s: %.2f PMKs/s, (%.2f%% occupancy)" % (core.name, (resCount / compTime) if compTime > 0 else 0 , compTime * 100.0 / tdiff))
        self.tell("Batchprocessing done.")

    def benchmark(self):
        import cpyrit
        cp = cpyrit.CPyrit(maxBufferSize=10000)
        self.tell("Running benchmark for at least 60 seconds...\n")
        t = time.time()
        pws = ['barbarbar']*3500
        while time.time() - t < 60:
            cp.enqueue('foo', pws, block=True)
            while True:
                r = cp.dequeue(block=False)
                if not r:
                    break
        for r in cp:
            pass
        total = 0
        tdiff = time.time() - t
        for core in cp.cores:
            resCount, compTime = core.getStats()
            perf = resCount / compTime if compTime > 0 else 0
            self.tell("%s: %.2f PMKs/s (%.2f%% occupancy)" % (core.name, perf, compTime * 100.0 / tdiff))
            total += perf
        self.tell("\nBenchmark done. %.2f PMKs/s total." % total)

    def selftest(self):
        import cpyrit
        cp = cpyrit.CPyrit(maxBufferSize=10000)
        self.tell("Running selftest for at least 60 seconds...\n")
        workunits = []
        t = time.time()
        err = False
        while time.time() - t < 60 and not err:
            essid = random.choice(PMK_TESTVECTORS.keys())
            pws = [random.choice(PMK_TESTVECTORS[essid].keys()) for i in xrange(random.randrange(10, 500))]
            workunits.append((essid, pws))
            cp.enqueue(essid, pws, block=True)
            while True:
                r = cp.dequeue(block=False)
                if r is not None:
                    essid, pws = workunits.pop(0)
                    if [PMK_TESTVECTORS[essid][pw] for pw in pws] != [tuple(map(ord, pmk)) for pmk in r]:
                        err = True
                        break
                if err or not r:
                    break
        if not err:
            for r in cp:
                essid, pws = workunits.pop(0)
                if [PMK_TESTVECTORS[essid][pw] for pw in pws] != [tuple(map(ord, pmk)) for pmk in r]:
                    err = True
                    break
        if err or len(workunits) != 0 or len(cp) != 0:
            self.tell("!!! WARNING !!!\n"\
                      "At least some results are definitly invalid."\
                      "This may be caused by a bug in Pyrit, faulty hardware or malicious network clients. Do not trust this installation...\n",
                      stream=sys.stderr)
        else:
            self.tell("All results verified. Your installation seems OK.")
    
    def verify(self):
        import cpyrit
        cp = cpyrit.CPyrit()
        if self.options.essid is not None:
            if self.options.essid not in self.essidstore:
                self.tell("The ESSID '%s' is not found in the repository" % self.options.essid, stream=sys.stderr)
                return
            else:
                essids = [self.options.essid]
        else:
            essids = self.essidstore
        totalResCount = 0
        err = False
        startTime = time.time()
        workunits = []
        try: 
            for essid in essids:
                essid_object = self.essidstore[essid]
                self.tell("Verifying ESSID '%s'" % essid_object.essid)
                for key, results in essid_object:
                    pws = random.sample(results, int(len(results) * 0.1))
                    if len(pws) > 0:
                        workunits.append((essid, key, tuple([results[pw] for pw in pws])))
                        cp.enqueue(essid, pws, True)
                    newResults = cp.dequeue(block=False)
                    if newResults is not None:
                        totalResCount += len(newResults)
                        e, k, pmks = workunits.pop(0)
                        if pmks != newResults:
                            self.tell("Workunit %s for ESSID '%s' seems corrupted." % (k, e), stream=sys.stderr)
                            err = True
                    tdiff = time.time() - startTime
                    self.tell("Computed %i PMKs in %i seconds; %i PMKs per second.\r" % (totalResCount, tdiff, totalResCount / tdiff), end=None, sep=None)
                for newResults in cp:
                    totalResCount += len(newResults)
                    e, k, pmks = workunits.pop(0)
                    if pmks != newResults:
                        self.tell("Workunit %s for ESSID '%s' seems corrupted." % (k, e), stream=sys.stderr)
                        err = True
            self.tell("\nVerified %i PMKs with %.2f PMKs/s." % (totalResCount, totalResCount / (time.time() - startTime)))
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")
        if err:
            self.tell("\nAt least one workunit-file contains invalid results. There are two options now:\n"
                      "* The results on the disk are really invalid. You should mistrust the entire repository but at least delete and recompute the offending ESSIDs.\n"
                      "* The result on the disk are correct but your installation is broken and currently computes invalid results.\n"
                      "Run 'selftest' for an extensive self-test in order to tell the two options apart.",
                      stream=sys.stderr)
        else:
            self.tell("Everything seems OK.")

    def serve(self):
        self.tell('Booting...', end=None)
        httpd = PyritServer()
        self.tell('%s, %i cores:' % (httpd.name, len(httpd.cp.cores)))
        for i, core in enumerate(httpd.cp.cores):
            self.tell("#%i '%s'" % (i+1, core))
        try:
            httpd.serve_forever()
        except (KeyboardInterrupt, SystemExit):
            self.tell("Exiting...")


class PyrFile(object):
    def __init__(self, essid, filename):
        self.results = {}
        self.essid = essid
        self.filename = filename
        self.key = None 
        if os.path.exists(filename):
            self.key = filename.split(os.path.sep)[-1][:-4]
            f = open(filename, "rb")
            buf = f.read()
            f.close()
            if len(buf) > 0:
                md = hashlib.md5()
                preheadfmt = "<4sH"
                preheadsize = struct.calcsize(preheadfmt)
                magic, essidlen = struct.unpack(preheadfmt, buf[:preheadsize])
                assert magic == "PYR2"
                headfmt = "<%ssi%ss" % (essidlen, md.digest_size)
                headsize = struct.calcsize(headfmt)
                essid, numElems, digest = struct.unpack(headfmt, buf[preheadsize:preheadsize+headsize])
                assert essid == self.essid
                pmkoffset = preheadsize + headsize
                pwoffset = pmkoffset + numElems * 32
                md.update(essid)
                md.update(buf[pmkoffset:])
                if md.digest() != digest:
                    raise Exception, "Digest check failed on PyrFile '%s'." % filename
                self.results = dict(itertools.izip(
                                    zlib.decompress(buf[pwoffset:]).split("\n"),
                                    [buf[pmkoffset + i*32:pmkoffset + i*32 + 32] for i in xrange(numElems)]
                                    ))
                assert len(self.results) == numElems

    def __contains__(self, key):
        return key in self.results

    def __iter__(self):
        return self.results.__iter__()
            
    def __len__(self):
        return len(self.results)

    def savefile(self):
        pws, pmks = itertools.izip(*self.results.items())
        pmkbuffer = "".join(pmks)
        pwbuffer = zlib.compress("\n".join(pws), 1)
        md = hashlib.md5()
        md.update(self.essid)
        md.update(pmkbuffer)
        md.update(pwbuffer)
        buf = cStringIO.StringIO()
        buf.write(struct.pack("<4sH%ssi%ss" % (len(self.essid), md.digest_size), "PYR2", len(self.essid), self.essid, len(pws), md.digest()))
        buf.write(pmkbuffer)
        buf.write(pwbuffer)
        f = open(self.filename, "wb")
        f.write(buf.getvalue())

class ESSID(object):
    def __init__(self, path):
        self.path = path
        try:
            self.f = open(os.path.join(path, "essid"), "rb")
        except IOError:
            raise IOError, "ESSID not found or not accessible."
        self.essid = self.f.read()

    def __len__(self):
        return len([x[:-4] for x in os.listdir(self.path) if x[-4:] == '.pyr'])

    def __repr__(self):
        return self.essid

    def __iter__(self):
        for key, results in ((k, dict(self._getPyrFile(k).results)) for k in (x[:-4] for x in os.listdir(self.path) if x[-4:] == '.pyr')):
            yield (key, results)

    def __getitem__(self, key):
        return self._getPyrFile(key)

    def close(self):
        if self.f is not None:
            self.f.close()
        self.f = None
        self.path = None
        self.essid = None
     
    def _getPyrFile(self, key):
        if isinstance(key, str):
            fname = key
        elif isinstance(key, PasswordFile):
            fname = key.key
        else:
            raise AssertionError, "Don't know how to get results based on parameter of class '%s'." % key.__class__
        return PyrFile(self.essid, os.path.join(self.path, fname+".pyr"))


class EssidStore(object):
    def __init__(self,basepath):
        self.essidpath = basepath
        self._makedir(self.essidpath)

    def _makedir(self, pathname):
        if not os.path.exists(pathname):
            os.makedirs(pathname)

    def _getessidroot(self, essid):
        return os.path.join(self.essidpath, hashlib.md5(essid).hexdigest()[:8])

    def __getitem__(self, essid):
        return ESSID(self._getessidroot(essid))
        
    def __len__(self):
        return len([x for x in self])

    def __iter__(self):
        essids = set()
        for essid_hash in os.listdir(self.essidpath):
            f = open(os.path.join(self.essidpath, essid_hash, 'essid'), "rb")
            essid = f.read()
            f.close()
            if essid_hash == hashlib.md5(essid).hexdigest()[:8]:
                essids.add(essid)
            else:
                print >>sys.stderr, "ESSID %s seems to be corrupted." % essid_hash
        for essid in sorted(essids):
            yield essid
            
    def __contains__(self, key):
        essid_root = self._getessidroot(key)
        if os.path.exists(essid_root):
            f = open(os.path.join(essid_root, 'essid'), 'rb')
            essid = f.read()
            f.close()
            return essid == key
        else:
            return False

    def create_essid(self, essid):
        if len(essid) < 3 or len(essid) > 32:
            raise ValueError, "ESSID invalid."
        essid_root = self._getessidroot(essid)
        self._makedir(essid_root)
        f = open(os.path.join(essid_root, 'essid'), 'wb')
        f.write(essid)
        f.close()

    def delete_essid(self, essid):
        if essid not in self:
            raise KeyError, "ESSID not in store."
        essid_root = self._getessidroot(essid)
        for fname in os.listdir(essid_root):
            if fname[-4:] == '.pyr':
                os.unlink(os.path.join(essid_root, fname))
        os.unlink(os.path.join(essid_root, 'essid'))
        os.rmdir(essid_root)


class PasswordFile(object):
    def __init__(self, filepath, filename=None):
        self.bucket = set()
        self.filepath = filepath
        self.key = None
        if filename:
            f = open(os.path.join(filepath, filename), "rb")
            buf = f.read()
            f.close()
            if len(buf) > 0:
                if buf[:4] != "PAW2":
                    raise Exception, "'%s' is not a PasswordFile." % filename
                md = hashlib.md5()
                md.update(buf[4+md.digest_size:])
                if md.digest() != buf[4:4+md.digest_size]:
                    raise Exception, "Digest check failed for %s" % filename
                self.key = md.hexdigest()
                if filename[-3-len(self.key):-3] != self.key:
                    raise Exception, "File '%s' doesn't match the key '%s'." % (filename, md.hexdigest())
                self.bucket = frozenset(zlib.decompress(buf[4+md.digest_size:]).split("\n"))

    def __repr__(self):
        return "Passwordfile '%s' in '%s'" % (self.key, self.filepath)

    def __iter__(self):
        return self.bucket.__iter__()
            
    def __len__(self):
        return len(self.bucket)

    def savefile(self):
        md = hashlib.md5()
        b = zlib.compress("\n".join(sorted(self.bucket)), 1)
        md.update(b)
        buf = cStringIO.StringIO()
        buf.write('PAW2')
        buf.write(md.digest())
        buf.write(b)
        if self.key and self.key != md.hexdigest():
            raise Exception, "PasswordFile unstable."
        if not os.path.exists(self.filepath):
            os.makedirs(self.filepath)
        f = open(os.path.join(self.filepath, md.hexdigest() + ".pw"), "wb")
        f.write(buf.getvalue())


class PasswordStore(object):
    h1_list = ["%02.2X" % i for i in xrange(256)]
    def __init__(self, basepath):
        self.passwdpath = basepath
        if not os.path.exists(self.passwdpath):
            os.makedirs(self.passwdpath)
        self.pwbuffer = {}

    def _getfiles(self, filt=None):
        pwfiles = {}
        for pw_h1 in [x for x in os.listdir(self.passwdpath) if x == filt or filt is None]:
            for pw in [x for x in os.listdir(os.path.join(self.passwdpath, pw_h1)) if x[-3:] == '.pw']:
                pwfiles[pw[:len(pw)-3]] = (os.path.join(self.passwdpath, pw_h1), pw)
        return pwfiles

    def __iter__(self):
        for pwpath, pwfile in self._getfiles().values():
            yield PasswordFile(pwpath, pwfile)

    def __getitem__(self, key):
        return PasswordFile(*self._getfiles()[key])

    def _flush_bucket(self, pw_h1, bucket):
        if len(bucket) == 0:
            return
        for pwpath, pwfile in self._getfiles(pw_h1).values():
            bucket -= PasswordFile(pwpath, pwfile).bucket
        if len(bucket) == 0:
            return
        f = PasswordFile(filepath = os.path.join(self.passwdpath, pw_h1))
        f.bucket = bucket
        f.savefile()

    def flush_buffer(self):
        for pw_h1, pwlist in [(pw_h1, list(pwbucket)) for pw_h1, pwbucket in self.pwbuffer.iteritems() if len(pwbucket) > 0]:
            for pwslice in (set(pwlist[x:x+10000]) for x in xrange(0, len(pwlist), 10000)):
                self._flush_bucket(pw_h1, pwslice)
            self.pwbuffer[pw_h1] = set()

    def store_password(self, passwd):
        passwd = passwd.strip()
        if len(passwd) < 8 or len(passwd) > 63:
            return
        pw_h1 = PasswordStore.h1_list[hash(passwd) & 0xFF]
        pw_bucket = self.pwbuffer.setdefault(pw_h1, set())
        pw_bucket.add(passwd)
        if len(pw_bucket) >= 10000:
            self._flush_bucket(pw_h1, pw_bucket)
            self.pwbuffer[pw_h1] = set()


class PyritServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    class PyritHandler(BaseHTTPServer.BaseHTTPRequestHandler):
        def do_GET(self):
            self.parsed_path = urlparse.urlparse(self.path)
            self.params = {}
            if len(self.parsed_path.query) > 0:
                self.params.update([x.split('=') for x in self.parsed_path.query.split("&")])

            if self.parsed_path.path == "/":
                self.send_response(httplib.OK)
                self.end_headers()
                self.wfile.write('%s, started %s\n\nActive cores:\n' % (self.server.name, time.ctime(self.server.started)))
                for i, core in enumerate(self.server.cp.cores):
                    self.wfile.write(" #%i '%s', did %i PMKs so far\n" % (i, core, core.getStats()[0]))
                self.wfile.write('\nActive clients:\n')
                for i, (name, joined, lastseen, inCount, outCount) in enumerate(self.server.getClientStats()):
                    self.wfile.write(" #%i '%s'\n  Joined %s, last seen %s\n  %i passwords queued, %i processed\n\n" %
                                        (i, name, time.ctime(joined), time.ctime(lastseen), inCount, outCount))

            elif self.parsed_path.path == "/ENQUEUE":
                if 'client' not in self.params or self.params['client'] not in self.server.clients:
                    self.send_response(httplib.FORBIDDEN)
                    self.end_headers()
                else:
                    buf = self.rfile.read(int(self.headers.getheader('Content-Length')))
                    digest = hashlib.sha1()
                    essid, pwbuffer = buf[digest.digest_size:].split('\n', 1)
                    digest.update(essid)
                    digest.update(pwbuffer)
                    if digest.digest() != buf[:digest.digest_size]:
                        raise Exception, "Digest check failed."
                    self.server.enqueue(self.params['client'], essid, pwbuffer.split('\n'))
                    self.send_response(httplib.OK)
                    self.end_headers()
                    self.wfile.write(str(len(self.server)))

            elif self.parsed_path.path == "/DEQUEUE":
                if 'client' not in self.params or self.params['client'] not in self.server.clients:
                    self.send_response(httplib.FORBIDDEN)
                    self.end_headers()
                else:
                    t = time.time()
                    while True:
                        res = self.server.dequeue(self.params['client'])
                        if res is not None or time.time() - t > 3.0:
                            break
                        else:
                            time.sleep(0.1)
                    if res is None:
                        self.send_response(httplib.PROCESSING)
                        self.end_headers()
                    else:
                        buf = ''.join(res)
                        digest = hashlib.sha1()
                        digest.update(buf)
                        self.send_response(httplib.OK)
                        self.end_headers()
                        self.wfile.write(digest.digest())
                        self.wfile.write(buf)

            elif self.parsed_path.path == "/REGISTER":
                client = self.server.registerClient(self.client_address[0])
                self.send_response(httplib.OK)
                self.end_headers()
                self.wfile.write(client.uuid)

            else:
                self.send_response(httplib.NOT_FOUND)
                self.end_headers()
        do_POST = do_GET

    class PyritServerCleaner(threading.Thread):
        def __init__(self, server):
            threading.Thread.__init__(self)
            self.server = server
            self.setDaemon(True)
            self.start()
            
        def run(self):
            while True:
                self.server.cv.acquire()
                try:
                    for client_uuid, client in self.server.clients.items():
                        if time.time() - client.lastseen > 60:
                            del self.server.clients[client_uuid]
                finally:
                    self.server.cv.release()
                time.sleep(15)

    class PyritClient(object):
        def __init__(self, host):
            self.host = host
            self.uuid = str(uuid.uuid4())
            self.joined = self.lastseen = time.time()
            self.inCount = self.outCount = 0
            self.outQueue = []
            
        def __repr__(self):
            return '%s@%s' % (self.host, self.uuid)

    def __init__(self):
        BaseHTTPServer.HTTPServer.__init__(self, ('', 19935), PyritServer.PyritHandler)
        import cpyrit
        self.cp = cpyrit.CPyrit()
        self.started = time.time()
        self.clients = {}
        self.wu_clients = []
        self.cv = threading.Condition()
        self.name = "Pyrit 0.2.3-dev"
        self.cleaner = PyritServer.PyritServerCleaner(self)

    def registerClient(self, host):
        self.cv.acquire()
        try:
            client = PyritServer.PyritClient(host)
            self.clients[client.uuid] = client
            return client
        finally:
            self.cv.release()
    
    def getClientStats(self):
        self.cv.acquire()
        try:
            return tuple([(str(c), c.joined, c.lastseen, c.inCount, c.outCount) for c in self.clients.itervalues()])
        finally:
            self.cv.release()

    def enqueue(self, client_uuid, essid, passwordlist):
        assert self.cleaner.isAlive()
        self.cv.acquire()
        try:
            if client_uuid not in self.clients:
                raise KeyError, "Client not registered"
            client = self.clients[client_uuid]
            self.cp.enqueue(essid, passwordlist, block=False)
            self.wu_clients.append(client_uuid)
            client.lastseen = time.time()
            client.inCount += len(passwordlist)
        finally:
            self.cv.release()
        
    def dequeue(self, client_uuid):
        assert self.cleaner.isAlive()
        self.cv.acquire()
        try:
            if client_uuid not in self.clients:
                raise KeyError, "Client not registered"
            while True:
                results = self.cp.dequeue(block=False)
                if results is None:
                    break
                else:
                    wu_client_uuid = self.wu_clients.pop(0)
                    if wu_client_uuid in self.clients:
                        wu_client = self.clients[wu_client_uuid]
                        wu_client.outQueue.append(results)
                        wu_client.outCount += len(results)
            client = self.clients[client_uuid]
            client.lastseen = time.time()
            if len(client.outQueue) > 0:
                return client.outQueue.pop(0)
            else:
                return None
        finally:
            self.cv.release() 

    def __len__(self):
        self.cv.acquire()
        try:
            return len(self.cp)
        finally:
            self.cv.release()

if __name__ == "__main__":
    try:
        import psyco
    except ImportError:
        pass
    else:
        psyco.full()
    Pyrit_CLI().init()

